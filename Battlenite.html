<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MiniRoyale</title>
    <style>
        /* Basic Reset & Body Styling */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #333;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }

        /* Game Container */
        #game-container {
            position: relative;
            /* Set dimensions dynamically via JS based on map size */
            overflow: hidden;
            background-color: #5a8a5a; /* Default grass color */
            border: 2px solid #000;
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        /* Map Tiles */
        .tile {
             position: absolute;
             /* size set by JS */
             z-index: 0; /* Ensure tiles are behind everything else */
             box-sizing: border-box; /* Include border in size */
             /* border: 1px dotted #eee; */ /* Optional: for debugging tile layout */
        }
        .tile-grass { background-color: #5a8a5a; }
        .tile-sand { background-color: #f0e68c; } /* Beach */
        .tile-water { background-color: #4682b4; } /* Ocean */
        /* Forest/Rocky removed as explicit tiles, now treated as obstacles */

        /* Ensure game container default matches grass */
        #game-container {
            /* ... other styles ... */
            background-color: #5a8a5a; /* Default grass color */
        }


        /* Entities (Player, AI) */
        .entity {
            position: absolute;
            /* size set by JS */
            border-radius: 50%; /* Circle shape */
            border: 1px solid #000;
            box-sizing: border-box;
            z-index: 10;
            transition: transform 0.05s linear; /* Smooth rotation */
        }
        .player {
            background-color: #007bff; /* Blue */
        }
        .ai {
            background-color: #dc3545; /* Red */
        }
        .entity::after { /* Direction indicator */
            content: '';
            position: absolute;
            width: 40%;
            height: 3px;
            background-color: #000;
            top: 50%;
            left: 50%;
            transform: translate(0, -50%); /* Center vertically, offset horizontally */
        }

        /* Health Bar (Above Entities) */
        .health-bar {
            position: absolute;
            bottom: 110%; /* Position above the entity */
            left: 50%;
            transform: translateX(-50%);
            width: 30px; /* Fixed width */
            height: 5px;
            background-color: #ccc;
            border: 1px solid #000;
            z-index: 11;
        }
        .health-bar-inner {
            height: 100%;
            background-color: #28a745; /* Green */
            width: 100%; /* Starts full */
            transition: width 0.1s linear;
        }

        /* Obstacles */
        .obstacle {
            position: absolute;
            background-color: #696969; /* Grey */
            border: 1px solid #000;
            z-index: 5;
        }
        .bush {
            background-color: #556b2f; /* Dark Olive Green */
            opacity: 0.8;
            border-radius: 30%;
            z-index: 6; /* Bushes above ground obstacles */
        }
         .wall {
             background-color: #a0522d; /* Sienna */
             z-index: 5;
         }


        /* Chests */
        .chest {
            position: absolute;
            background-color: #ffd700; /* Gold */
            border: 1px solid #8b4513; /* Brown border */
            width: 20px;
            height: 20px;
            z-index: 7;
            cursor: pointer; /* Indicate interactable */
        }

        /* Items */
        .item {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 1px solid #000;
            z-index: 8;
        }
        .item-weapon-ar { background-color: #ff7f50; } /* Coral */
        .item-weapon-smg { background-color: #add8e6; } /* Light Blue */
        .item-weapon-shotgun { background-color: #90ee90; } /* Light Green */
        .item-healthkit { background-color: #f08080; } /* Light Coral */

        /* Projectiles */
        .projectile {
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: #ffeb3b; /* Yellow */
            border-radius: 50%;
            z-index: 9;
            pointer-events: none; /* Don't interfere with mouse clicks */
        }

        /* Storm */
        #storm-circle {
            position: absolute;
            border: 5px dashed rgba(138, 43, 226, 0.6); /* Purple, semi-transparent */
            border-radius: 50%;
            box-sizing: border-box;
            pointer-events: none; /* Don't block clicks */
            z-index: 20;
            /* Size and position set by JS */
             /* Add a visual effect for being outside */
            box-shadow: 0 0 0 5000px rgba(138, 43, 226, 0.15); /* Outer shadow */
        }


        /* UI Elements */
        #ui-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none; /* Allow clicks to pass through UI background */
            z-index: 30;
            color: #fff;
            text-shadow: 1px 1px 2px black;
        }
        #ui-left, #ui-right, #ui-center {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            pointer-events: auto; /* Re-enable pointer events for buttons inside */
        }
         #ui-center {
             position: absolute;
             bottom: 10px; /* Align with others */
             left: 50%;
             transform: translateX(-50%);
         }

        #health-bar-ui {
            width: 150px;
            height: 20px;
            background-color: #ccc;
            border: 1px solid #000;
            margin-bottom: 5px;
        }
        #health-bar-ui-inner {
            height: 100%;
            background-color: #28a745; /* Green */
            width: 100%;
            transition: width 0.1s linear;
        }
        #weapon-info, #health-kit-info, #player-count, #storm-timer {
             margin-top: 5px;
             font-size: 14px;
        }

        /* Minimap */
        #minimap-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px; /* Example size */
            height: 150px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            overflow: hidden;
            z-index: 30;

        }
        #minimap-player {
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: #007bff; /* Player color */
            border-radius: 50%;
            /* Position updated by JS */
        }
        #minimap-storm {
             position: absolute;
             border: 1px dashed rgba(138, 43, 226, 0.8);
             border-radius: 50%;
             /* Size and position updated by JS */
        }
         /* Add dots for AI on minimap if desired */
         .minimap-ai {


            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #dc3545; /* AI color */
            border-radius: 50%;
            /* Position updated by JS */

         }



        /* Touch Controls */
        #touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px; /* Area for controls */
            z-index: 25;
            pointer-events: none; /* Container doesn't block */
            display: none; /* Hidden by default, shown on touch devices */
        }
        #joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto; /* Enable touch */
        }
        #joystick-thumb {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Thumb doesn't block area */
        }
        #shoot-button {
            position: absolute;
            bottom: 35px; /* Adjusted position */
            right: 35px; /* Adjusted position */
            width: 80px;
            height: 80px;
            background-color: rgba(255, 80, 80, 0.5);
            border-radius: 50%;
            pointer-events: auto; /* Enable touch */
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
        }
         #health-kit-button {
             position: absolute;
             bottom: 130px; /* Position above shoot */
             right: 45px;
             width: 60px;
             height: 60px;
             background-color: rgba(80, 255, 80, 0.5);
             border-radius: 50%;
             pointer-events: auto; /* Enable touch */
             display: flex;
             justify-content: center;
             align-items: center;
             color: white;
             font-size: 12px;
             text-align: center;
         }

        /* Game Over / Win Screen */
        #message-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-size: 2em;
            z-index: 50;
        }
         #message-screen button {
             margin-top: 20px;
             padding: 10px 20px;
             font-size: 0.8em;
         }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- Dynamic elements (player, AI, items, etc.) will be added here by JS -->
        <div id="storm-circle"></div>
    </div>

    <div id="ui-container">
        <div id="ui-left">
            <div id="health-bar-ui"><div id="health-bar-ui-inner"></div></div>
            <div id="health-kit-info">Health Kits: 0</div>
        </div>
        <div id="ui-center">
            <div id="storm-timer">Storm: Preparing...</div>
            <div id="player-count">Players Left: 11</div>
        </div>
        <div id="ui-right">
             <div id="weapon-info">Weapon: None</div>
             <!-- Ammo would go here if implemented -->
        </div>
    </div>

    <div id="minimap-container">
        <div id="minimap-player"></div>
        <div id="minimap-storm"></div>
        <!-- AI dots will be added here by JS -->
    </div>

    <div id="touch-controls">
        <div id="joystick-area">
            <div id="joystick-thumb"></div>
        </div>
        <button id="shoot-button">SHOOT</button>
        <button id="health-kit-button">USE KIT</button>
    </div>

    <div id="message-screen">
        <div id="message-text"></div>
        <button id="restart-button">Play Again</button>
    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const uiContainer = document.getElementById('ui-container');
        const healthBarUiInner = document.getElementById('health-bar-ui-inner');
        const weaponInfo = document.getElementById('weapon-info');
        const healthKitInfo = document.getElementById('health-kit-info');
        const playerCount = document.getElementById('player-count');
        const stormTimer = document.getElementById('storm-timer');
        const stormCircle = document.getElementById('storm-circle');
        const minimapContainer = document.getElementById('minimap-container');
        const minimapPlayer = document.getElementById('minimap-player');
        const minimapStorm = document.getElementById('minimap-storm');
        const messageScreen = document.getElementById('message-screen');
        const messageText = document.getElementById('message-text');
        const restartButton = document.getElementById('restart-button');

        // --- AI Constants ---
        const AI_CHEST_SEARCH_RADIUS = 450; // How far AI looks for chests
        const AI_ENEMY_SEARCH_RADIUS = 400; // How far AI looks for enemies
        const AI_CHEST_INTERACT_DIST = 25;  // How close AI needs to be to 'open' a chest
        const AI_STUCK_THRESHOLD = 0.75; // Seconds before attempting to unstick AI
        const AI_UNSTICK_FORCE = 8; // Pixels to nudge when stuck

        // --- Map Generation Constants ---
        const OCEAN_BORDER_TILES = 3; // How many tiles thick the ocean is
        const BEACH_BORDER_TILES = 2; // How many tiles thick the beach is


        // --- Touch Controls ---
        const touchControls = document.getElementById('touch-controls');
        const joystickArea = document.getElementById('joystick-area');
        const joystickThumb = document.getElementById('joystick-thumb');
        const shootButton = document.getElementById('shoot-button');
        const healthKitButton = document.getElementById('health-kit-button');

        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickCurrentX = 0;
        let joystickCurrentY = 0;
        let touchShootActive = false;
        let touchUseKitActive = false;
        const MAX_JOYSTICK_DIST = 30; // Max pixels the thumb can move from center

        // --- Game Constants ---
        const TILE_SIZE = 40; // Pixel size of a grid tile
        const MAP_WIDTH_TILES = 40;
        const MAP_HEIGHT_TILES = 40;
        const MAP_WIDTH_PX = MAP_WIDTH_TILES * TILE_SIZE;
        const MAP_HEIGHT_PX = MAP_HEIGHT_TILES * TILE_SIZE;
        const PLAYER_SIZE = 20;
        const AI_SIZE = 20;
        const PLAYER_SPEED = 150; // Pixels per second
        const AI_SPEED = 120;
        const PROJECTILE_SIZE = 5;
        const PROJECTILE_SPEED = 400;
        const CHEST_SIZE = 20;
        const ITEM_SIZE = 15;
        const MAX_HEALTH = 100;
        const MAX_HEALTH_KITS = 3;
        const HEALTH_KIT_HEAL_AMOUNT = 50;
        const HEALTH_KIT_USE_TIME = 1000; // ms
        const OBSTACLE_MIN_SIZE = TILE_SIZE * 0.8;
        const OBSTACLE_MAX_SIZE = TILE_SIZE * 2.5;
        const BUSH_SIZE = TILE_SIZE * 1.5;
        const WALL_THICKNESS = 10;
        const WALL_MIN_LENGTH = TILE_SIZE * 2; // 80
        const WALL_MAX_LENGTH = TILE_SIZE * 6; // 240
        const MAX_NEARBY_WALLS_FOR_SPAWN = 2; // Reject spawn if >= this many walls are close
        const WALL_CHECK_RADIUS = TILE_SIZE * 1.5; // How far to check for nearby walls

        const WEAPONS = {
            'Sniper': { name: 'Sniper', damage: 75, range: 2000, fireRate: 2000, projectileSpeed: 1000, color: '#d3d3d3' },
            'AR': { name: 'AR', damage: 15, range: 400, fireRate: 150, projectileSpeed: 500, color: '#ff7f50' },
            'SMG': { name: 'SMG', damage: 8, range: 250, fireRate: 70, projectileSpeed: 600, color: '#add8e6' },
            'Shotgun': { name: 'Shotgun', damage: 25, range: 150, fireRate: 800, projectileSpeed: 350, pellets: 5, spread: 0.4, color: '#90ee90' }, // radians spread
        };

        const STORM_PHASES = [
            // Phase 0 in logic (displayed as Phase 1 to user initially)
            { waitDuration: 20, shrinkDuration: 10, radiusFraction: 0.8, damage: 1 },
            // Phase 1 in logic
            { waitDuration: 15, shrinkDuration: 10, radiusFraction: 0.6, damage: 2 },
            // Phase 2
            { waitDuration: 10, shrinkDuration: 7, radiusFraction: 0.4, damage: 5 },
            // Phase 3
            { waitDuration: 5, shrinkDuration: 7, radiusFraction: 0.2, damage: 8 },
            // Phase 4
            { waitDuration: 1, shrinkDuration: 5, radiusFraction: 0.1, damage: 10 },
            // Phase 5 (Final circle)
            { waitDuration: Infinity, shrinkDuration: 0, radiusFraction: 0.1, damage: 15}
        ];

        // --- Game State ---
        let gameState = {
            player: null,
            ai: [],
            projectiles: [],
            items: [],
            chests: [],
            obstacles: [], // Includes bushes and walls
            mapGrid: [], // Optional: Can store terrain type per tile
            keysDown: {},
            mousePos: { x: 0, y: 0 },
            isMouseDown: false,
            gameTime: 0,
            lastTimestamp: 0,
            deltaTime: 0,
            currentStormPhase: -1, // Starts before phase 0 (initial wait)
            stormRadius: MAP_WIDTH_PX,
            stormCenterX: MAP_WIDTH_PX / 2,
            stormCenterY: MAP_HEIGHT_PX / 2,
            nextStormRadius: MAP_WIDTH_PX,
            nextStormCenterX: MAP_WIDTH_PX / 2,
            nextStormCenterY: MAP_HEIGHT_PX / 2,
            stormTimer: STORM_PHASES[0].waitDuration,
            isStormShrinking: false,
            gameOver: false,
            minimapAIDots: [],
            isUsingHealthKit: false,
            healthKitUseTimer: 0,
        };

        // --- Utility Functions ---
        function getRandom(min, max) {
            return Math.random() * (max - min) + min;
        }

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function checkCollision(rect1, rect2) {
            if (rect1.width === undefined || rect1.height === undefined || rect2.width === undefined || rect2.height === undefined) {
                console.warn("Collision check with undefined width/height:", rect1, rect2);
                return false;
            }
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }


        function getDistance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        // --- Entity Class (Restored Constructor) ---
        class Entity {
            constructor(x, y, size, color, type = 'entity') {
                this.x = x;
                this.y = y;
                this.size = size;
                this.width = size;
                this.height = size;
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.health = MAX_HEALTH;
                this.maxHealth = MAX_HEALTH;
                this.type = type;

                this.element = document.createElement('div');
                this.element.classList.add('entity', type);
                this.element.style.width = `${size}px`;
                this.element.style.height = `${size}px`;
                this.element.style.backgroundColor = color;
                this.element.style.left = `${this.x - size / 2}px`;
                this.element.style.top = `${this.y - size / 2}px`;

                this.healthBarElement = document.createElement('div');
                this.healthBarElement.classList.add('health-bar');
                this.healthBarInnerElement = document.createElement('div');
                this.healthBarInnerElement.classList.add('health-bar-inner');
                this.healthBarElement.appendChild(this.healthBarInnerElement);

                gameContainer.appendChild(this.element);
                gameContainer.appendChild(this.healthBarElement);

                this.lastShotTime = 0;
                this.weapon = null;
                this.isHiding = false;

                this.aiTarget = null;
                this.aiReactionTime = type === 'ai' ? getRandom(0.2, 0.6) : 0;
                this.aiAimStartTime = 0;
                this.aiIsAiming = false;
                this.aiInaccuracy = type === 'ai' ? getRandom(0.03, 0.1) : 0;
                this.aiLastPosition = { x: this.x, y: this.y };
                this.aiTimeStuck = 0;

                this.aiWanderTargetX = null;
                this.aiWanderTargetY = null;
                this.aiWanderTimer = 0;
                this.aiState = 'idle';
            }

            update(dt) {
                const prevX = this.x;
                const prevY = this.y;
                let nextX = this.x + this.vx * dt;
                let nextY = this.y + this.vy * dt;

                let collidedWithBoundary = false;
                const checkRadius = this.size / 2;
                const boundaryPoints = [
                     { x: nextX - checkRadius, y: nextY - checkRadius }, { x: nextX + checkRadius, y: nextY - checkRadius },
                     { x: nextX - checkRadius, y: nextY + checkRadius }, { x: nextX + checkRadius, y: nextY + checkRadius },
                     { x: nextX + (this.vx > 0 ? checkRadius : (this.vx < 0 ? -checkRadius : 0)), y: nextY },
                     { x: nextX, y: nextY + (this.vy > 0 ? checkRadius : (this.vy < 0 ? -checkRadius : 0))}
                ];

                for (const point of boundaryPoints) {
                     const tileX = Math.floor(point.x / TILE_SIZE);
                     const tileY = Math.floor(point.y / TILE_SIZE);

                     if (gameState.mapGrid[tileY]?.[tileX] === 'ocean') {
                         collidedWithBoundary = true;
                         const currentTileX = Math.floor(this.x / TILE_SIZE);
                         const currentTileY = Math.floor(this.y / TILE_SIZE);

                         if (tileX !== currentTileX && gameState.mapGrid[currentTileY]?.[tileX] === 'ocean') {
                             this.vx = 0; nextX = this.x;
                         }
                         if (tileY !== currentTileY && gameState.mapGrid[tileY]?.[currentTileX] === 'ocean') {
                             this.vy = 0; nextY = this.y;
                         }
                          const finalTileX = Math.floor(nextX / TILE_SIZE);
                          const finalTileY = Math.floor(nextY / TILE_SIZE);
                          if(gameState.mapGrid[finalTileY]?.[finalTileX] === 'ocean') {
                              this.vx = 0; this.vy = 0; nextX = this.x; nextY = this.y;
                          }
                         break;
                     }
                }
                 this.x = nextX;
                 this.y = nextY;

                 const entityRect = { x: this.x - this.size / 2, y: this.y - this.size / 2, width: this.size, height: this.size };
                 gameState.obstacles.forEach(obstacle => {
                     if (!obstacle.isBush) {
                         const obstacleRect = { x: obstacle.x, y: obstacle.y, width: obstacle.width, height: obstacle.height };
                         if (checkCollision(entityRect, obstacleRect)) {
                             const overlapX = (this.size / 2 + obstacle.width / 2) - Math.abs(this.x - (obstacle.x + obstacle.width / 2));
                             const overlapY = (this.size / 2 + obstacle.height / 2) - Math.abs(this.y - (obstacle.y + obstacle.height / 2));
                             if (overlapX < overlapY) {
                                 this.x += (this.x < obstacle.x + obstacle.width / 2) ? -overlapX : overlapX;
                                 this.vx = 0;
                             } else {
                                 this.y += (this.y < obstacle.y + obstacle.height / 2) ? -overlapY : overlapY;
                                 this.vy = 0;
                             }
                              entityRect.x = this.x - this.size / 2;
                              entityRect.y = this.y - this.size / 2;
                         }
                     }
                 });

                 this.x = Math.max(this.size / 2, Math.min(MAP_WIDTH_PX - this.size / 2, this.x));
                 this.y = Math.max(this.size / 2, Math.min(MAP_HEIGHT_PX - this.size / 2, this.y));

                this.isHiding = false;
                const currentEntityRect = { x: this.x - this.size / 2, y: this.y - this.size / 2, width: this.size, height: this.size };
                gameState.obstacles.forEach(obstacle => {
                   if (obstacle.isBush) {
                       const bushRect = { x: obstacle.x, y: obstacle.y, width: obstacle.width, height: obstacle.height };
                       if (checkCollision(currentEntityRect, bushRect)) {
                          this.isHiding = true;
                       }
                   }
                });

                if (this.element) {
                    this.element.style.opacity = this.isHiding ? '0.5' : '1';
                    this.element.style.left = `${this.x - this.size / 2}px`;
                    this.element.style.top = `${this.y - this.size / 2}px`;
                    this.element.style.transform = `rotate(${this.angle}rad)`;
                } else {
                    console.error("Entity element missing for:", this);
                }

                if (this.healthBarElement && this.healthBarInnerElement) {
                    this.healthBarElement.style.left = `${this.x}px`;
                    this.healthBarElement.style.top = `${this.y - this.size / 2 - 10}px`;
                    const healthPercent = Math.max(0, (this.health / this.maxHealth) * 100);
                    this.healthBarInnerElement.style.width = `${healthPercent}%`;
                } else {
                     console.error("Entity health bar elements missing for:", this);
                }
            }


            shoot(targetX, targetY) {
                const now = gameState.gameTime;
                if (!this.weapon || !WEAPONS[this.weapon] || now < this.lastShotTime + WEAPONS[this.weapon].fireRate) {
                    return;
                }

                this.lastShotTime = now;
                const weapon = WEAPONS[this.weapon];
                let angleToTarget = getAngle(this.x, this.y, targetX, targetY);

                if (this.type === 'ai' && this.aiInaccuracy > 0) {
                    angleToTarget += getRandom(-this.aiInaccuracy, this.aiInaccuracy);
                }

                if (weapon.name === 'Shotgun') {
                    for (let i = 0; i < weapon.pellets; i++) {
                        const spreadAngle = angleToTarget + getRandom(-weapon.spread / 2, weapon.spread / 2);
                        createProjectile(this.x, this.y, spreadAngle, weapon, this);
                    }
                } else {
                     createProjectile(this.x, this.y, angleToTarget, weapon, this);
                }
            }

            takeDamage(amount) {
                if (this.health <= 0) return;
                this.health -= amount;
                if (this.healthBarInnerElement) {
                    const healthPercent = Math.max(0, (this.health / this.maxHealth) * 100);
                    this.healthBarInnerElement.style.width = `${healthPercent}%`;
                }
                if (this.health <= 0) {
                    this.die();
                }
                if (this.type === 'player') {
                    updatePlayerUI();
                }
            }

            die() {
                console.log(`${this.type} died`);
                if (this.element && this.element.parentNode) this.element.parentNode.removeChild(this.element);
                if (this.healthBarElement && this.healthBarElement.parentNode) this.healthBarElement.parentNode.removeChild(this.healthBarElement);
                this.element = null;
                this.healthBarElement = null;
                this.healthBarInnerElement = null;

                if (this.type === 'player') {
                     gameState.player = null;
                     showEndScreen("Game Over!");
                     gameState.gameOver = true;
                } else if (this.type === 'ai') {
                    const index = gameState.ai.indexOf(this);
                    if (index > -1) {
                        gameState.ai.splice(index, 1);
                        if (gameState.minimapAIDots[index] && gameState.minimapAIDots[index].parentNode) {
                           gameState.minimapAIDots[index].parentNode.removeChild(gameState.minimapAIDots[index]);
                        }
                        gameState.minimapAIDots.splice(index, 1);
                    }
                    if (gameState.ai.length === 0 && gameState.player) {
                       showEndScreen("You Win!");
                       gameState.gameOver = true;
                    }
                }
                updatePlayerCountUI();
            }

            pickupItem(item) {
                 if (!item) return false;
                if (item.itemType === 'weapon') {
                    this.weapon = item.weaponType;
                    if (this.type === 'player') updatePlayerUI();
                    console.log(`${this.type} picked up ${item.weaponType}`);
                } else if (item.itemType === 'healthkit') {
                    if (this.type === 'player') {
                        if (this.healthKits === undefined) this.healthKits = 0;
                        if (this.healthKits < MAX_HEALTH_KITS) {
                            this.healthKits++;
                            updatePlayerUI();
                            console.log(`Player picked up Health Kit (${this.healthKits}/${MAX_HEALTH_KITS})`);
                        } else {
                             return false;
                        }
                    } else {
                        return false;
                    }
                }
                 return true;
            }
        }


        // --- Projectile Class ---
        class Projectile {
            constructor(x, y, angle, weaponStats, shooter) {
                this.x = x;
                this.y = y;
                this.size = PROJECTILE_SIZE;
                this.width = PROJECTILE_SIZE;
                this.height = PROJECTILE_SIZE;
                this.speed = weaponStats.projectileSpeed;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.damage = weaponStats.damage;
                this.range = weaponStats.range;
                this.distanceTraveled = 0;
                this.shooter = shooter;

                this.element = document.createElement('div');
                this.element.classList.add('projectile');
                this.element.style.width = `${this.size}px`;
                this.element.style.height = `${this.size}px`;
                this.element.style.left = `${x - this.size / 2}px`;
                this.element.style.top = `${y - this.size / 2}px`;
                gameContainer.appendChild(this.element);
            }

            update(dt) {
                const moveDist = this.speed * dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.distanceTraveled += moveDist;

                if (this.element) {
                     this.element.style.left = `${this.x - this.size / 2}px`;
                     this.element.style.top = `${this.y - this.size / 2}px`;
                 }

                if (this.distanceTraveled >= this.range) {
                    this.remove();
                    return true;
                }
                if (this.x < 0 || this.x > MAP_WIDTH_PX || this.y < 0 || this.y > MAP_HEIGHT_PX) {
                    this.remove();
                    return true;
                }
                 const projectileRect = { x: this.x - this.size / 2, y: this.y - this.size / 2, width: this.size, height: this.size };
                 for (const obstacle of gameState.obstacles) {
                     if (!obstacle.isBush) {
                         const obstacleRect = { x: obstacle.x, y: obstacle.y, width: obstacle.width, height: obstacle.height };
                         if (checkCollision(projectileRect, obstacleRect)) {
                             this.remove();
                             return true;
                         }
                     }
                 }
                const entitiesToCheck = [gameState.player, ...gameState.ai].filter(e => e && e.health > 0 && e !== this.shooter);
                for (const entity of entitiesToCheck) {
                    const entityRect = { x: entity.x - entity.size / 2, y: entity.y - entity.size / 2, width: entity.size, height: entity.size };
                    if (checkCollision(projectileRect, entityRect)) {
                        entity.takeDamage(this.damage);
                        this.remove();
                        return true;
                    }
                }
                return false;
            }
            remove() {
                 if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                 }
                 this.element = null;
            }
        }

        // --- Item Class ---
        class Item {
            constructor(x, y, itemType, weaponType = null) {
                this.x = x;
                this.y = y;
                this.size = ITEM_SIZE;
                this.width = ITEM_SIZE;
                this.height = ITEM_SIZE;
                this.itemType = itemType;
                this.weaponType = weaponType;

                this.element = document.createElement('div');
                this.element.classList.add('item');
                this.element.style.width = `${this.size}px`;
                this.element.style.height = `${this.size}px`;
                this.element.style.left = `${x - this.size / 2}px`;
                this.element.style.top = `${y - this.size / 2}px`;

                if (itemType === 'weapon' && weaponType) {
                     this.element.classList.add(`item-weapon-${weaponType.toLowerCase()}`);
                } else if (itemType === 'healthkit') {
                    this.element.classList.add('item-healthkit');
                } else if (itemType === 'weapon' && !weaponType) {
                    console.warn("Created weapon item without weaponType:", x, y);
                }
                gameContainer.appendChild(this.element);
            }
            remove() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
                this.element = null;
            }
        }

         // --- Chest Class ---
         class Chest {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = CHEST_SIZE;
                 this.width = CHEST_SIZE;
                 this.height = CHEST_SIZE;
                this.opened = false;

                this.element = document.createElement('div');
                this.element.classList.add('chest');
                this.element.style.width = `${this.size}px`;
                this.element.style.height = `${this.size}px`;
                this.element.style.left = `${x - this.size / 2}px`;
                this.element.style.top = `${y - this.size / 2}px`;
                gameContainer.appendChild(this.element);
            }
            open() {
                if (this.opened) return;
                this.opened = true;
                if (this.element && this.element.parentNode) this.element.parentNode.removeChild(this.element);
                this.element = null;

                const numItems = getRandomInt(1, 2);
                const weaponChoices = Object.keys(WEAPONS);
                for (let i = 0; i < numItems; i++) {
                    let itemType = 'weapon';
                     let weaponType = null;
                     if(i > 0 && Math.random() < 0.3) {
                         itemType = 'healthkit';
                     } else {
                         if (weaponChoices.length > 0) {
                            weaponType = weaponChoices[getRandomInt(0, weaponChoices.length - 1)];
                         } else {
                            console.warn("No weapons defined in WEAPONS constant to spawn from chest.");
                            continue;
                         }
                     }
                    const spawnX = this.x + getRandom(-15, 15);
                    const spawnY = this.y + getRandom(-15, 15);
                    const newItem = new Item(spawnX, spawnY, itemType, weaponType);
                    gameState.items.push(newItem);
                }
            }
         }

         // --- Obstacle Function (using simple objects) ---
         function createObstacle(x, y, width, height, isBush = false, isWall = false) {
             const obstacle = {
                 x, y, width, height, isBush, isWall,
                 element: document.createElement('div')
             };
             obstacle.element.classList.add('obstacle');
             if (isBush) obstacle.element.classList.add('bush');
             if (isWall) obstacle.element.classList.add('wall');
             obstacle.element.style.left = `${x}px`;
             obstacle.element.style.top = `${y}px`;
             obstacle.element.style.width = `${width}px`;
             obstacle.element.style.height = `${height}px`;
             gameContainer.appendChild(obstacle.element);
             return obstacle;
         }


         function initGame() {
            console.log("Initializing game...");
             gameState = {
                player: null, ai: [], projectiles: [], items: [], chests: [], obstacles: [],
                mapGrid: [], keysDown: {}, mousePos: { x: 0, y: 0 }, isMouseDown: false,
                gameTime: 0, lastTimestamp: 0, deltaTime: 0,
                currentStormPhase: -1,
                stormRadius: Math.max(MAP_WIDTH_PX, MAP_HEIGHT_PX) * 1.5,
                stormCenterX: MAP_WIDTH_PX / 2, stormCenterY: MAP_HEIGHT_PX / 2,
                nextStormRadius: Math.max(MAP_WIDTH_PX, MAP_HEIGHT_PX) * 1.5,
                nextStormCenterX: MAP_WIDTH_PX / 2, nextStormCenterY: MAP_HEIGHT_PX / 2,
                stormTimer: STORM_PHASES[0].waitDuration,
                isStormShrinking: false, gameOver: false, minimapAIDots: [],
                isUsingHealthKit: false, healthKitUseTimer: 0,
            };

            gameContainer.innerHTML = '';
            minimapContainer.innerHTML = '';
            gameContainer.appendChild(stormCircle);
            minimapContainer.appendChild(minimapPlayer);
            minimapContainer.appendChild(minimapStorm);

            stormCircle.style.width = `${gameState.stormRadius * 2}px`;
            stormCircle.style.height = `${gameState.stormRadius * 2}px`;
            stormCircle.style.left = `${gameState.stormCenterX - gameState.stormRadius}px`;
            stormCircle.style.top = `${gameState.stormCenterY - gameState.stormRadius}px`;
            minimapPlayer.style.left = '0px'; minimapPlayer.style.top = '0px';
            minimapStorm.style.width = '0px'; minimapStorm.style.height = '0px';

            gameContainer.style.width = `${MAP_WIDTH_PX}px`;
            gameContainer.style.height = `${MAP_HEIGHT_PX}px`;

            const mapTilesContainer = document.createElement('div');
            mapTilesContainer.id = 'map-tiles';
            mapTilesContainer.style.position = 'absolute';
            mapTilesContainer.style.width = '100%';
            mapTilesContainer.style.height = '100%';
            mapTilesContainer.style.zIndex = 0;
            gameContainer.appendChild(mapTilesContainer);

            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                gameState.mapGrid[y] = [];
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    let tileType = 'grass';
                    if (x < OCEAN_BORDER_TILES || x >= MAP_WIDTH_TILES - OCEAN_BORDER_TILES ||
                        y < OCEAN_BORDER_TILES || y >= MAP_HEIGHT_TILES - OCEAN_BORDER_TILES) {
                        tileType = 'ocean';
                    } else if (x < OCEAN_BORDER_TILES + BEACH_BORDER_TILES || x >= MAP_WIDTH_TILES - OCEAN_BORDER_TILES - BEACH_BORDER_TILES ||
                             y < OCEAN_BORDER_TILES + BEACH_BORDER_TILES || y >= MAP_HEIGHT_TILES - OCEAN_BORDER_TILES - BEACH_BORDER_TILES) {
                        tileType = 'sand';
                    }
                    gameState.mapGrid[y][x] = tileType;
                    const tileElement = document.createElement('div');
                    tileElement.classList.add('tile');
                    tileElement.classList.add(tileType === 'ocean' ? 'tile-water' : tileType === 'sand' ? 'tile-sand' : 'tile-grass');
                    tileElement.style.width = `${TILE_SIZE}px`; tileElement.style.height = `${TILE_SIZE}px`;
                    tileElement.style.left = `${x * TILE_SIZE}px`; tileElement.style.top = `${y * TILE_SIZE}px`;
                    mapTilesContainer.appendChild(tileElement);
                }
            }

            function isSpawnLocationValid(x, y, size, checkWalls = true) {
                 if (x - size / 2 < 0 || x + size / 2 > MAP_WIDTH_PX || y - size / 2 < 0 || y + size / 2 > MAP_HEIGHT_PX) return false;
                 const pointsToCheck = [ { cx: x - size / 2, cy: y - size / 2 }, { cx: x + size / 2, cy: y - size / 2 }, { cx: x - size / 2, cy: y + size / 2 }, { cx: x + size / 2, cy: y + size / 2 }, { cx: x, cy: y } ];
                 for (const point of pointsToCheck) {
                    const tileX = Math.floor(point.cx / TILE_SIZE); const tileY = Math.floor(point.cy / TILE_SIZE);
                    if (gameState.mapGrid[tileY]?.[tileX] === 'ocean') return false;
                 }
                 const entityRect = { x: x - size / 2, y: y - size / 2, width: size, height: size };
                 let nearbyWallCount = 0;
                 for (const obs of gameState.obstacles) {
                    if (!obs.isBush) {
                        const obstacleRect = { x: obs.x, y: obs.y, width: obs.width, height: obs.height };
                        if (checkCollision(entityRect, obstacleRect)) return false;
                        if (checkWalls && obs.isWall) {
                            const obsCenterX = obs.x + obs.width / 2; const obsCenterY = obs.y + obs.height / 2;
                            if (getDistance(x, y, obsCenterX, obsCenterY) < WALL_CHECK_RADIUS) nearbyWallCount++;
                        }
                    }
                 }
                 if (checkWalls && nearbyWallCount >= MAX_NEARBY_WALLS_FOR_SPAWN) return false;
                 return true;
            }

             const NUM_OBSTACLES = 50; const NUM_BUSHES = 30; const NUM_WALL_STRUCTURES = 8; // Increased wall structures
             for (let i = 0; i < NUM_OBSTACLES; i++) {
                 let obsX, obsY, obsSize, validObsSpawn; let attempts = 0;
                 do {
                     obsSize = getRandom(OBSTACLE_MIN_SIZE, OBSTACLE_MAX_SIZE);
                     const minSpawnX = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE; const maxSpawnX = MAP_WIDTH_PX - minSpawnX - obsSize;
                     const minSpawnY = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE; const maxSpawnY = MAP_HEIGHT_PX - minSpawnY - obsSize;
                     if(maxSpawnX <= minSpawnX || maxSpawnY <= minSpawnY) { validObsSpawn = false; break; }
                     obsX = getRandom(minSpawnX, maxSpawnX); obsY = getRandom(minSpawnY, maxSpawnY);
                     validObsSpawn = isSpawnLocationValid(obsX + obsSize / 2, obsY + obsSize / 2, obsSize, false); attempts++;
                 } while (!validObsSpawn && attempts < 50);
                 if (validObsSpawn) gameState.obstacles.push(createObstacle(obsX, obsY, obsSize, obsSize));
             }
             for (let i = 0; i < NUM_BUSHES; i++) {
                let bushX, bushY, validBushSpawn; let attempts = 0; const bushSize = BUSH_SIZE;
                do {
                     const minSpawnX = OCEAN_BORDER_TILES * TILE_SIZE; const maxSpawnX = MAP_WIDTH_PX - minSpawnX - bushSize;
                     const minSpawnY = OCEAN_BORDER_TILES * TILE_SIZE; const maxSpawnY = MAP_HEIGHT_PX - minSpawnY - bushSize;
                     if(maxSpawnX <= minSpawnX || maxSpawnY <= minSpawnY) { validBushSpawn = false; break; }
                     bushX = getRandom(minSpawnX, maxSpawnX); bushY = getRandom(minSpawnY, maxSpawnY);
                     validBushSpawn = isSpawnLocationValid(bushX + bushSize / 2, bushY + bushSize / 2, bushSize, false); attempts++;
                 } while (!validBushSpawn && attempts < 50);
                  if (validBushSpawn) gameState.obstacles.push(createObstacle(bushX, bushY, bushSize, bushSize, true));
             }

            for (let i = 0; i < NUM_WALL_STRUCTURES; i++) {
                let attempts = 0; let structurePlaced = false;
                do {
                    const startX = getRandom(TILE_SIZE * (OCEAN_BORDER_TILES + BEACH_BORDER_TILES + 1), MAP_WIDTH_PX - TILE_SIZE * (OCEAN_BORDER_TILES + BEACH_BORDER_TILES + 1) - WALL_MAX_LENGTH);
                    const startY = getRandom(TILE_SIZE * (OCEAN_BORDER_TILES + BEACH_BORDER_TILES + 1), MAP_HEIGHT_PX - TILE_SIZE * (OCEAN_BORDER_TILES + BEACH_BORDER_TILES + 1) - WALL_MAX_LENGTH);
                    const structureType = getRandomInt(1, 3); // 1=L, 2=U, 3=Rect
                    let structureValid = isSpawnLocationValid(startX, startY, TILE_SIZE, false);

                    if (structureValid) {
                        if (structureType === 3) { // Rectangle with a door
                            const width = getRandom(WALL_MIN_LENGTH, WALL_MAX_LENGTH);
                            const height = getRandom(WALL_MIN_LENGTH, WALL_MAX_LENGTH);
                            const doorSize = TILE_SIZE * 1.25; // Ensure player can pass
                            const wallToHaveDoor = getRandomInt(0, 3); // 0:Top, 1:Bottom, 2:Left, 3:Right

                            // Top Wall
                            if (wallToHaveDoor === 0 && width > doorSize) {
                                const doorStart = getRandom(0, width - doorSize);
                                if (doorStart > 0) gameState.obstacles.push(createObstacle(startX, startY, doorStart, WALL_THICKNESS, false, true));
                                if (doorStart + doorSize < width) gameState.obstacles.push(createObstacle(startX + doorStart + doorSize, startY, width - (doorStart + doorSize), WALL_THICKNESS, false, true));
                            } else {
                                gameState.obstacles.push(createObstacle(startX, startY, width, WALL_THICKNESS, false, true));
                            }

                            // Bottom Wall
                            if (wallToHaveDoor === 1 && width > doorSize) {
                                const doorStart = getRandom(0, width - doorSize);
                                if (doorStart > 0) gameState.obstacles.push(createObstacle(startX, startY + height - WALL_THICKNESS, doorStart, WALL_THICKNESS, false, true));
                                if (doorStart + doorSize < width) gameState.obstacles.push(createObstacle(startX + doorStart + doorSize, startY + height - WALL_THICKNESS, width - (doorStart + doorSize), WALL_THICKNESS, false, true));
                            } else {
                                gameState.obstacles.push(createObstacle(startX, startY + height - WALL_THICKNESS, width, WALL_THICKNESS, false, true));
                            }

                            const usableHeightForVerticalWall = height - (2 * WALL_THICKNESS);
                            // Left Wall
                            if (wallToHaveDoor === 2 && usableHeightForVerticalWall > doorSize) {
                                const doorStartOffset = getRandom(0, usableHeightForVerticalWall - doorSize);
                                if (doorStartOffset > 0) {
                                    gameState.obstacles.push(createObstacle(startX, startY + WALL_THICKNESS, WALL_THICKNESS, doorStartOffset, false, true));
                                }
                                const remainingHeightBelowDoor = usableHeightForVerticalWall - doorStartOffset - doorSize;
                                if (remainingHeightBelowDoor > 0) {
                                    gameState.obstacles.push(createObstacle(startX, startY + WALL_THICKNESS + doorStartOffset + doorSize, WALL_THICKNESS, remainingHeightBelowDoor, false, true));
                                }
                            } else {
                                if (usableHeightForVerticalWall > 0) gameState.obstacles.push(createObstacle(startX, startY + WALL_THICKNESS, WALL_THICKNESS, usableHeightForVerticalWall, false, true));
                            }

                            // Right Wall
                            if (wallToHaveDoor === 3 && usableHeightForVerticalWall > doorSize) {
                                const doorStartOffset = getRandom(0, usableHeightForVerticalWall - doorSize);
                                if (doorStartOffset > 0) {
                                    gameState.obstacles.push(createObstacle(startX + width - WALL_THICKNESS, startY + WALL_THICKNESS, WALL_THICKNESS, doorStartOffset, false, true));
                                }
                                const remainingHeightBelowDoor = usableHeightForVerticalWall - doorStartOffset - doorSize;
                                if (remainingHeightBelowDoor > 0) {
                                    gameState.obstacles.push(createObstacle(startX + width - WALL_THICKNESS, startY + WALL_THICKNESS + doorStartOffset + doorSize, WALL_THICKNESS, remainingHeightBelowDoor, false, true));
                                }
                            } else {
                                 if (usableHeightForVerticalWall > 0) gameState.obstacles.push(createObstacle(startX + width - WALL_THICKNESS, startY + WALL_THICKNESS, WALL_THICKNESS, usableHeightForVerticalWall, false, true));
                            }
                            structurePlaced = true;
                        }
                        // TODO: Add logic for L and U shapes if desired, ensuring they also don't trap
                    }
                    attempts++;
                } while (!structurePlaced && attempts < 50);
                if (!structurePlaced) console.warn("Could not place wall structure", i);
            }

             let playerStartX, playerStartY, validPlayerSpawn; let playerSpawnAttempts = 0; const maxPlayerSpawnAttempts = 100;
             do {
                 const minSpawnX = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE + PLAYER_SIZE / 2; const maxSpawnX = MAP_WIDTH_PX - minSpawnX;
                 const minSpawnY = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE + PLAYER_SIZE / 2; const maxSpawnY = MAP_HEIGHT_PX - minSpawnY;
                 if (maxSpawnX <= minSpawnX || maxSpawnY <= minSpawnY) {
                    console.error("Playable area too small!"); playerStartX = MAP_WIDTH_PX / 2; playerStartY = MAP_HEIGHT_PX / 2; validPlayerSpawn = true; break;
                 }
                 playerStartX = getRandom(minSpawnX, maxSpawnX); playerStartY = getRandom(minSpawnY, maxSpawnY);
                 validPlayerSpawn = isSpawnLocationValid(playerStartX, playerStartY, PLAYER_SIZE, true); playerSpawnAttempts++;
             } while (!validPlayerSpawn && playerSpawnAttempts < maxPlayerSpawnAttempts);
             if (!validPlayerSpawn) {
                 console.warn(`Could not find clear player spawn. Falling back.`);
                 playerStartX = MAP_WIDTH_PX / 2; playerStartY = MAP_HEIGHT_PX / 2;
             }
             try {
                gameState.player = new Entity(playerStartX, playerStartY, PLAYER_SIZE, '#007bff', 'player');
                gameState.player.healthKits = 0;
             } catch (error) {
                 console.error("FATAL: Failed to create player entity!", error);
                 showEndScreen("Error: Failed to start game.");
                 gameState.gameOver = true; return;
             }

            const NUM_AI = 10;
            gameState.minimapAIDots = [];
            for (let i = 0; i < NUM_AI; i++) {
                 let spawnX, spawnY, validSpawn; let attempts = 0;
                 do {
                     const minSpawnX = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE + AI_SIZE / 2; const maxSpawnX = MAP_WIDTH_PX - minSpawnX;
                     const minSpawnY = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE + AI_SIZE / 2; const maxSpawnY = MAP_HEIGHT_PX - minSpawnY;
                     if (maxSpawnX <= minSpawnX || maxSpawnY <= minSpawnY) { validSpawn = false; break; }
                     spawnX = getRandom(minSpawnX, maxSpawnX); spawnY = getRandom(minSpawnY, maxSpawnY);
                     validSpawn = isSpawnLocationValid(spawnX, spawnY, AI_SIZE, true);
                     if (validSpawn && gameState.player && getDistance(spawnX, spawnY, gameState.player.x, gameState.player.y) < TILE_SIZE * 5) {
                         validSpawn = false;
                     }
                     attempts++;
                 } while (!validSpawn && attempts < 50);
                 if (validSpawn) {
                     try {
                        const ai = new Entity(spawnX, spawnY, AI_SIZE, '#dc3545', 'ai');
                        gameState.ai.push(ai);
                        const aiDot = document.createElement('div');
                        aiDot.classList.add('minimap-ai');
                        minimapContainer.appendChild(aiDot);
                        gameState.minimapAIDots.push(aiDot);
                     } catch (error) {
                         console.error(`Failed to create AI entity ${i}:`, error);
                     }
                 } else {
                     console.warn("Could not find valid spawn for AI", i);
                 }
             }

            const NUM_CHESTS = 40;
            for (let i = 0; i < NUM_CHESTS; i++) {
                 let spawnX, spawnY, validSpawn; let attempts = 0;
                 do {
                    const minSpawnX = OCEAN_BORDER_TILES * TILE_SIZE + CHEST_SIZE / 2; const maxSpawnX = MAP_WIDTH_PX - minSpawnX;
                    const minSpawnY = OCEAN_BORDER_TILES * TILE_SIZE + CHEST_SIZE / 2; const maxSpawnY = MAP_HEIGHT_PX - minSpawnY;
                    if (maxSpawnX <= minSpawnX || maxSpawnY <= minSpawnY) { validSpawn = false; break; }
                    spawnX = getRandom(minSpawnX, maxSpawnX); spawnY = getRandom(minSpawnY, maxSpawnY);
                    validSpawn = isSpawnLocationValid(spawnX, spawnY, CHEST_SIZE, true); attempts++;
                 } while (!validSpawn && attempts < 50);
                 if(validSpawn) gameState.chests.push(new Chest(spawnX, spawnY));
                 else console.warn("Could not find valid spawn for Chest", i);
            }

            if (gameState.gameOver) {
                console.log("Game initialization failed or stopped early.");
                return;
            }
            updatePlayerUI();
            updatePlayerCountUI();
            updateStormUI();
            hideEndScreen();
            addEventListeners();
            gameState.lastTimestamp = performance.now();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop(gameState.lastTimestamp);
            console.log("Game initialized and loop started.");
        }

        function addEventListeners() {
            window.addEventListener('keydown', (e) => {
                gameState.keysDown[e.key.toLowerCase()] = true;
                if (e.key.toLowerCase() === 'e' && gameState.player && !gameState.isUsingHealthKit && gameState.player.healthKits > 0) {
                    startUsingHealthKit();
                }
            });
            window.addEventListener('keyup', (e) => {
                gameState.keysDown[e.key.toLowerCase()] = false;
                 if (e.key.toLowerCase() === 'e' || ['w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
                     cancelUsingHealthKit();
                 }
            });
            window.addEventListener('mousemove', (e) => {
                const rect = gameContainer.getBoundingClientRect();
                if (rect) {
                    gameState.mousePos.x = e.clientX - rect.left;
                    gameState.mousePos.y = e.clientY - rect.top;
                }
            });
            window.addEventListener('mousedown', (e) => {
                if (e.button === 0) { gameState.isMouseDown = true; cancelUsingHealthKit(); }
            });
            window.addEventListener('mouseup', (e) => {
                 if (e.button === 0) { gameState.isMouseDown = false; }
            });
            if ('ontouchstart' in window) {
                 touchControls.style.display = 'block';
                 joystickArea.addEventListener('touchstart', (e) => {
                     e.preventDefault(); joystickActive = true; const touch = e.touches[0]; const rect = joystickArea.getBoundingClientRect();
                     joystickStartX = rect.left + rect.width / 2; joystickStartY = rect.top + rect.height / 2;
                     joystickCurrentX = touch.clientX; joystickCurrentY = touch.clientY; cancelUsingHealthKit();
                 }, { passive: false });
                 joystickArea.addEventListener('touchmove', (e) => {
                     e.preventDefault(); if (!joystickActive) return; const touch = e.touches[0];
                     joystickCurrentX = touch.clientX; joystickCurrentY = touch.clientY;
                 }, { passive: false });
                 window.addEventListener('touchend', (e) => {
                     let relatedToEnd = false;
                     for(let i=0; i < e.changedTouches.length; i++){
                         const touch = e.changedTouches[i]; const rect = joystickArea.getBoundingClientRect();
                         const currentJoystickCenterX = rect.left + rect.width / 2; const currentJoystickCenterY = rect.top + rect.height / 2;
                         const distFromCenter = getDistance(touch.clientX, touch.clientY, currentJoystickCenterX, currentJoystickCenterY);
                         if(distFromCenter < joystickArea.offsetWidth) { relatedToEnd = true; break; }
                     }
                     if(joystickActive && relatedToEnd) {
                         joystickActive = false; joystickThumb.style.transform = 'translate(-50%, -50%)';
                     }
                 });
                 shootButton.addEventListener('touchstart', (e) => { e.preventDefault(); touchShootActive = true; cancelUsingHealthKit(); }, { passive: false });
                 shootButton.addEventListener('touchend', (e) => { e.preventDefault(); touchShootActive = false; });
                 healthKitButton.addEventListener('touchstart', (e) => {
                     e.preventDefault();
                     if (gameState.player && !gameState.isUsingHealthKit && gameState.player.healthKits > 0) startUsingHealthKit();
                 }, { passive: false });
            }
            restartButton.addEventListener('click', initGame);
        }

        function startUsingHealthKit() {
            if (gameState.isUsingHealthKit || !gameState.player || gameState.player.healthKits <= 0 || gameState.player.health >= MAX_HEALTH) return;
            gameState.isUsingHealthKit = true;
            gameState.healthKitUseTimer = HEALTH_KIT_USE_TIME;
            if (gameState.player.element) gameState.player.element.style.boxShadow = '0 0 10px 5px lightgreen';
            gameState.player.vx = 0; gameState.player.vy = 0;
        }
        function updateHealthKitUsage(dt_ms) {
            if (!gameState.isUsingHealthKit || !gameState.player) return;
            gameState.healthKitUseTimer -= dt_ms;
            if (gameState.healthKitUseTimer <= 0) {
                finishUsingHealthKit();
            }
        }
        function finishUsingHealthKit() {
            if (!gameState.isUsingHealthKit || !gameState.player) return;
            gameState.player.health = Math.min(MAX_HEALTH, gameState.player.health + HEALTH_KIT_HEAL_AMOUNT);
            gameState.player.healthKits--;
            gameState.isUsingHealthKit = false;
            gameState.healthKitUseTimer = 0;
             if (gameState.player.element) gameState.player.element.style.boxShadow = '';
            updatePlayerUI();
        }
        function cancelUsingHealthKit() {
             if (gameState.isUsingHealthKit) {
                 gameState.isUsingHealthKit = false;
                 gameState.healthKitUseTimer = 0;
                 if(gameState.player && gameState.player.element) gameState.player.element.style.boxShadow = '';
             }
        }

        function updatePlayer(dt) {
            if (!gameState.player || gameState.gameOver || gameState.isUsingHealthKit) return;
            let moveX = 0; let moveY = 0;
            if (gameState.keysDown['w']) moveY -= 1; if (gameState.keysDown['s']) moveY += 1;
            if (gameState.keysDown['a']) moveX -= 1; if (gameState.keysDown['d']) moveX += 1;

            if (joystickActive) {
                const dx = joystickCurrentX - joystickStartX; const dy = joystickCurrentY - joystickStartY;
                const dist = Math.min(MAX_JOYSTICK_DIST, getDistance(0, 0, dx, dy));
                const angle = Math.atan2(dy, dx);
                const clampedDx = Math.cos(angle) * dist; const clampedDy = Math.sin(angle) * dist;
                moveX = clampedDx / MAX_JOYSTICK_DIST; moveY = clampedDy / MAX_JOYSTICK_DIST;
                joystickThumb.style.transform = `translate(calc(-50% + ${clampedDx}px), calc(-50% + ${clampedDy}px))`;
            }

            const moveMagnitude = Math.sqrt(moveX * moveX + moveY * moveY);
            if (moveMagnitude > 1) {
                moveX /= moveMagnitude; moveY /= moveMagnitude;
            }
            gameState.player.vx = moveX * PLAYER_SPEED;
            gameState.player.vy = moveY * PLAYER_SPEED;
            gameState.player.angle = getAngle(gameState.player.x, gameState.player.y, gameState.mousePos.x, gameState.mousePos.y);
            if (gameState.isMouseDown || touchShootActive) {
                 gameState.player.shoot(gameState.mousePos.x, gameState.mousePos.y);
            }
            gameState.player.update(dt);
             const playerRect = { x: gameState.player.x - gameState.player.size / 2, y: gameState.player.y - gameState.player.size / 2, width: gameState.player.size, height: gameState.player.size };
             for (let i = gameState.items.length - 1; i >= 0; i--) {
                 const item = gameState.items[i];
                 if (!item) continue;
                 const itemRect = { x: item.x - item.size / 2, y: item.y - item.size / 2, width: item.size, height: item.size };
                 if (checkCollision(playerRect, itemRect)) {
                     if (gameState.player.pickupItem(item)) {
                        item.remove(); gameState.items.splice(i, 1);
                     }
                 }
             }
             const interactDist = gameState.player.size * 1.5;
             for (let i = gameState.chests.length - 1; i >= 0; i--) {
                 const chest = gameState.chests[i];
                 if (chest && !chest.opened) {
                      if (getDistance(gameState.player.x, gameState.player.y, chest.x, chest.y) < interactDist) {
                          chest.open();
                          gameState.chests.splice(i, 1);
                      }
                 }
             }
        }

        function updateAI(dt) {
            if (gameState.gameOver) return;
            gameState.ai.forEach((ai, aiIndex) => {
                if (!ai || ai.health <= 0 || !ai.element) {
                    const dot = gameState.minimapAIDots[aiIndex];
                    if (dot && dot.parentNode) dot.parentNode.removeChild(dot);
                    return;
                }
                let targetX = null; let targetY = null;
                let isShooting = false; let decidedAction = false;
                ai.aiState = 'idle';

                if (ai.weapon && !decidedAction) {
                    let closestEnemy = null; let minEnemyDist = AI_ENEMY_SEARCH_RADIUS;
                    const potentialTargets = [gameState.player, ...gameState.ai].filter(e => e && e.health > 0 && e !== ai && e.element);
                    potentialTargets.forEach(enemy => {
                        const dist = getDistance(ai.x, ai.y, enemy.x, enemy.y);
                        if (dist < minEnemyDist && !enemy.isHiding && hasLineOfSight(ai.x, ai.y, enemy.x, enemy.y)) {
                            minEnemyDist = dist; closestEnemy = enemy;
                        }
                    });
                    if (closestEnemy) {
                        ai.aiState = 'engaging'; decidedAction = true;
                        targetX = closestEnemy.x; targetY = closestEnemy.y;
                        const weaponRange = WEAPONS[ai.weapon]?.range ?? 0;
                        if (ai.aiTarget !== closestEnemy) {
                            ai.aiTarget = closestEnemy; ai.aiIsAiming = false; ai.aiAimStartTime = 0; ai.aiWanderTimer = 0;
                        }
                        if (minEnemyDist < weaponRange) {
                            if (!ai.aiIsAiming) { ai.aiIsAiming = true; ai.aiAimStartTime = gameState.gameTime; }
                            const timeSinceAimStart = (gameState.gameTime - ai.aiAimStartTime) / 1000;
                            if (ai.aiIsAiming && timeSinceAimStart >= ai.aiReactionTime) {
                                isShooting = true; ai.shoot(targetX, targetY);
                            } else { isShooting = false; }
                        } else { isShooting = false; ai.aiIsAiming = false; ai.aiAimStartTime = 0; }
                    } else {
                        if(ai.aiTarget) { ai.aiTarget = null; ai.aiIsAiming = false; ai.aiAimStartTime = 0; }
                    }
                }

                if (!ai.weapon && !decidedAction) {
                    let closestChest = null; let minChestDist = AI_CHEST_SEARCH_RADIUS;
                    gameState.chests.forEach((chest) => {
                        if (chest && !chest.opened) {
                            const dist = getDistance(ai.x, ai.y, chest.x, chest.y);
                            if (dist < minChestDist && hasLineOfSight(ai.x, ai.y, chest.x, chest.y)) {
                                minChestDist = dist; closestChest = chest;
                            }
                        }
                    });
                    if (closestChest) {
                        ai.aiState = 'looting'; decidedAction = true; ai.aiWanderTimer = 0;
                        if (minChestDist < AI_CHEST_INTERACT_DIST) {
                            closestChest.open();
                            const foundIndex = gameState.chests.indexOf(closestChest);
                            if (foundIndex > -1) gameState.chests.splice(foundIndex, 1);
                             const weaponChoices = Object.keys(WEAPONS);
                             if (weaponChoices.length > 0) {
                                ai.weapon = weaponChoices[getRandomInt(0, weaponChoices.length - 1)];
                             }
                             targetX = null; targetY = null;
                        } else { targetX = closestChest.x; targetY = closestChest.y; }
                    }
                }

                if (!decidedAction) {
                    const currentDistFromCenter = getDistance(ai.x, ai.y, gameState.stormCenterX, gameState.stormCenterY);
                    const nextDistFromCenter = getDistance(ai.x, ai.y, gameState.nextStormCenterX, gameState.nextStormCenterY);
                    const isOutsideCurrent = currentDistFromCenter > gameState.stormRadius;
                    const isOutsideNext = nextDistFromCenter > gameState.nextStormRadius;
                    if (isOutsideCurrent && gameState.currentStormPhase >= 0) {
                        ai.aiState = 'fleeing'; decidedAction = true;
                        targetX = gameState.stormCenterX; targetY = gameState.stormCenterY;
                        ai.aiWanderTimer = 0;
                    } else if (gameState.isStormShrinking && isOutsideNext) {
                        ai.aiState = 'fleeing'; decidedAction = true;
                        targetX = gameState.nextStormCenterX; targetY = gameState.nextStormCenterY;
                        ai.aiWanderTimer = 0;
                    }
                }

                 if (!decidedAction) {
                     ai.aiState = 'wandering'; ai.aiWanderTimer -= dt;
                     if (ai.aiWanderTimer <= 0 || ai.aiWanderTargetX === null) {
                         const wanderDist = getRandom(150, 400); const wanderAngle = getRandom(0, Math.PI * 2);
                         let potentialX = ai.x + Math.cos(wanderAngle) * wanderDist;
                         let potentialY = ai.y + Math.sin(wanderAngle) * wanderDist;
                         const padding = TILE_SIZE;
                         potentialX = Math.max(padding, Math.min(MAP_WIDTH_PX - padding, potentialX));
                         potentialY = Math.max(padding, Math.min(MAP_HEIGHT_PX - padding, potentialY));
                         const targetTileX = Math.floor(potentialX / TILE_SIZE);
                         const targetTileY = Math.floor(potentialY / TILE_SIZE);
                         if (gameState.mapGrid[targetTileY]?.[targetTileX] !== 'ocean') {
                            ai.aiWanderTargetX = potentialX; ai.aiWanderTargetY = potentialY;
                            ai.aiWanderTimer = getRandom(4, 8);
                         } else { ai.aiWanderTimer = 0.1; ai.aiWanderTargetX = null; ai.aiWanderTargetY = null; }
                     }
                     if (ai.aiWanderTargetX !== null) {
                         targetX = ai.aiWanderTargetX; targetY = ai.aiWanderTargetY;
                         if (getDistance(ai.x, ai.y, targetX, targetY) < ai.size * 1.5) {
                             ai.aiWanderTimer = 0;
                         }
                     }
                 }

                if (targetX !== null && targetY !== null) {
                    ai.angle = getAngle(ai.x, ai.y, targetX, targetY);
                }
                ai.vx = 0; ai.vy = 0;
                if (!isShooting && targetX !== null && targetY !== null) {
                    const distToTarget = getDistance(ai.x, ai.y, targetX, targetY);
                    const stopDistance = (ai.aiState === 'looting' || ai.aiState === 'wandering') ? ai.size : -1;
                    if (distToTarget > stopDistance) {
                        const angleToTarget = ai.angle;
                        ai.vx = Math.cos(angleToTarget) * AI_SPEED;
                        ai.vy = Math.sin(angleToTarget) * AI_SPEED;
                    }
                }
                const intendedMovement = Math.abs(ai.vx) > 0.1 || Math.abs(ai.vy) > 0.1;
                const actualDistMoved = getDistance(ai.x, ai.y, ai.aiLastPosition.x, ai.aiLastPosition.y);
                 const stuckMoveThreshold = 0.5 * dt * 60;
                if (intendedMovement && actualDistMoved < stuckMoveThreshold) {
                    ai.aiTimeStuck += dt;
                } else { ai.aiTimeStuck = 0; }
                ai.aiLastPosition.x = ai.x; ai.aiLastPosition.y = ai.y;
                if (ai.aiTimeStuck > AI_STUCK_THRESHOLD) {
                    const nudgeAngle = getRandom(0, Math.PI * 2);
                    ai.vx = Math.cos(nudgeAngle) * AI_SPEED * 0.6;
                    ai.vy = Math.sin(nudgeAngle) * AI_SPEED * 0.6;
                    ai.aiTimeStuck = 0; ai.aiIsAiming = false; ai.aiAimStartTime = 0; ai.aiWanderTimer = 0.1;
                }
                ai.update(dt);
            });
        }

        function hasLineOfSight(x1, y1, x2, y2) {
            const dx = x2 - x1; const dy = y2 - y1; const dist = Math.sqrt(dx * dx + dy * dy);
            const steps = Math.max(1, Math.floor(dist / (TILE_SIZE / 2)));
            for (let i = 1; i <= steps; i++) {
                const checkX = x1 + (dx / steps) * i; const checkY = y1 + (dy / steps) * i;
                const pointRect = { x: checkX - 1, y: checkY - 1, width: 2, height: 2 };
                for (const obstacle of gameState.obstacles) {
                    if (!obstacle.isBush) {
                         const obstacleRect = { x: obstacle.x, y: obstacle.y, width: obstacle.width, height: obstacle.height };
                         if (checkCollision(pointRect, obstacleRect)) return false;
                    }
                }
            }
            return true;
        }


        function updateProjectiles(dt) {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const projectile = gameState.projectiles[i];
                if (projectile) {
                    const removed = projectile.update(dt);
                    if (removed) gameState.projectiles.splice(i, 1);
                } else {
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        function createProjectile(x, y, angle, weaponStats, shooter) {
             if (!weaponStats) {
                 console.error("Attempted to create projectile with undefined weaponStats", shooter);
                 return;
             }
            const projectile = new Projectile(x, y, angle, weaponStats, shooter);
            gameState.projectiles.push(projectile);
        }

        function updateStorm(dt) {
             if (typeof dt !== 'number' || dt <= 0 || isNaN(dt)) {
                 updateStormUI(); updateMinimapStorm(); return;
             }
             if (gameState.gameOver || typeof gameState.stormTimer !== 'number' || isNaN(gameState.stormTimer)) {
                 updateStormUI(); updateMinimapStorm(); return;
             }

             gameState.stormTimer -= dt;

             if (gameState.stormTimer <= 0 && gameState.stormTimer !== Infinity) {
                 if (!gameState.isStormShrinking) {
                     gameState.currentStormPhase++;
                     const phaseIndex = Math.min(gameState.currentStormPhase, STORM_PHASES.length - 1);
                     const currentPhaseData = STORM_PHASES[phaseIndex];
                     if (!currentPhaseData) { console.error("Missing storm phase data for index:", phaseIndex); return; }

                     if (currentPhaseData.shrinkDuration > 0) {
                        gameState.isStormShrinking = true;
                        gameState.stormTimer = currentPhaseData.shrinkDuration;
                        const mapCenterRadius = Math.min(MAP_WIDTH_PX, MAP_HEIGHT_PX) / 2;
                        const nextRadius = mapCenterRadius * currentPhaseData.radiusFraction;
                        gameState.nextStormRadius = Math.max(5, nextRadius);
                        const currentRadius = gameState.stormRadius;
                        const maxOffset = Math.max(0, currentRadius - gameState.nextStormRadius);
                        const angle = getRandom(0, Math.PI * 2);
                        const offset = getRandom(0, maxOffset * 0.8);
                        gameState.nextStormCenterX = gameState.stormCenterX + Math.cos(angle) * offset;
                        gameState.nextStormCenterY = gameState.stormCenterY + Math.sin(angle) * offset;
                        gameState.nextStormCenterX = Math.max(gameState.nextStormRadius, Math.min(MAP_WIDTH_PX - gameState.nextStormRadius, gameState.nextStormCenterX));
                        gameState.nextStormCenterY = Math.max(gameState.nextStormRadius, Math.min(MAP_HEIGHT_PX - gameState.nextStormRadius, gameState.nextStormCenterY));
                        console.log(`Storm Phase ${phaseIndex + 1} START SHRINK. Target radius ${Math.round(gameState.nextStormRadius)}px. Timer: ${gameState.stormTimer.toFixed(1)}s`);
                     } else {
                         console.log(`Storm Phase ${phaseIndex + 1} reached final size. No further shrinking.`);
                         gameState.stormTimer = Infinity;
                     }
                 } else {
                     gameState.isStormShrinking = false;
                     gameState.stormRadius = gameState.nextStormRadius;
                     gameState.stormCenterX = gameState.nextStormCenterX;
                     gameState.stormCenterY = gameState.nextStormCenterY;
                     const nextPhaseIndex = Math.min(gameState.currentStormPhase + 1, STORM_PHASES.length - 1);
                     const nextPhaseData = STORM_PHASES[nextPhaseIndex];
                     if (!nextPhaseData) { console.error("Missing next storm phase data for index:", nextPhaseIndex); return; }
                     gameState.stormTimer = nextPhaseData.waitDuration;
                     const currentPhaseIndex = Math.min(gameState.currentStormPhase, STORM_PHASES.length - 1);
                     console.log(`Storm Phase ${currentPhaseIndex + 1} SHRINK COMPLETE. Radius: ${Math.round(gameState.stormRadius)}px. Waiting ${gameState.stormTimer === Infinity ? 'Infinite' : Math.round(gameState.stormTimer)+'s'}.`);
                 }
             }

             if (gameState.currentStormPhase >= 0) {
                 const phaseIndex = Math.min(gameState.currentStormPhase, STORM_PHASES.length - 1);
                 const currentPhaseData = STORM_PHASES[phaseIndex];
                 if (currentPhaseData) {
                    const damagePerSecond = currentPhaseData.damage;
                    if (gameState.player && gameState.player.health > 0) {
                        //  VVVVVVVVVVV THIS IS THE FIX VVVVVVVVVVV
                        const playerDist = getDistance(gameState.player.x, gameState.player.y, gameState.stormCenterX, gameState.stormCenterY);
                        //  ^^^^^^^^^^^^^ THIS IS THE FIX ^^^^^^^^^^^^^
                        if (playerDist > gameState.stormRadius) {
                            gameState.player.takeDamage(damagePerSecond * dt);
                        }
                    }
                    gameState.ai.forEach(ai => {
                        if (ai && ai.health > 0) {
                             const aiDist = getDistance(ai.x, ai.y, gameState.stormCenterX, gameState.stormCenterY);
                             if (aiDist > gameState.stormRadius) {
                                 ai.takeDamage(damagePerSecond * dt);
                             }
                        }
                    });
                 }
             }
             updateStormUI();
             updateMinimapStorm();
        }

        function updatePlayerUI() {
            if (!gameState.player) {
                healthBarUiInner.style.width = '0%';
                weaponInfo.textContent = 'Weapon: None';
                healthKitInfo.textContent = 'Health Kits: 0';
                return;
            }
            const healthPercent = Math.max(0, (gameState.player.health / gameState.player.maxHealth) * 100);
            healthBarUiInner.style.width = `${healthPercent}%`;
            weaponInfo.textContent = `Weapon: ${gameState.player.weapon ? (WEAPONS[gameState.player.weapon]?.name ?? 'Unknown') : 'None'}`;
             healthKitInfo.textContent = `Health Kits: ${gameState.player.healthKits ?? 0}`;
        }

        function updatePlayerCountUI() {
            const validAICount = gameState.ai.filter(ai => ai && ai.health > 0).length;
            const count = (gameState.player && gameState.player.health > 0 ? 1 : 0) + validAICount;
            playerCount.textContent = `Players Left: ${count}`;
        }


        function updateStormUI() {
            let timerText = '';
            const phaseIndex = Math.min(gameState.currentStormPhase, STORM_PHASES.length - 1);
            // For display, phases are often 1-indexed. currentStormPhase is -1 for initial wait, 0 for first shrink/wait, etc.
            const displayPhaseNumber = gameState.currentStormPhase + 1; // So -1 -> 0, 0 -> 1, 1 -> 2

            if (gameState.currentStormPhase < 0) { // Initial wait before any shrinking phase has begun
                 timerText = `Preparing...`; // Default
                 if (typeof gameState.stormTimer === 'number' && !isNaN(gameState.stormTimer)) {
                    // FIX: Use gameState.stormTimer for the current countdown value
                    timerText = `Storm starts in ${Math.ceil(gameState.stormTimer)}s`;
                 }
            } else if (gameState.stormTimer === Infinity) { // Final circle of the current phase
                 timerText = `Phase ${displayPhaseNumber} Final Circle`;
            } else if (gameState.isStormShrinking) { // Current phase is actively shrinking
                 timerText = `Phase ${displayPhaseNumber} Shrinking: ${Math.ceil(gameState.stormTimer)}s`;
            } else { // Current phase done shrinking, now waiting for the *next* phase to start shrinking
                 // displayPhaseNumber is the current phase. We're waiting for displayPhaseNumber + 1.
                 timerText = `Phase ${displayPhaseNumber + 1} starts in ${Math.ceil(gameState.stormTimer)}s`;
            }

            stormTimer.textContent = `Storm: ${timerText}`;

            stormCircle.style.width = `${gameState.stormRadius * 2}px`;
            stormCircle.style.height = `${gameState.stormRadius * 2}px`;
            stormCircle.style.left = `${gameState.stormCenterX - gameState.stormRadius}px`;
            stormCircle.style.top = `${gameState.stormCenterY - gameState.stormRadius}px`;
        }

        function updateMinimap() {
            if (gameState.gameOver) return;
             const minimapWidth = minimapContainer.offsetWidth;
             const minimapHeight = minimapContainer.offsetHeight;

             if (gameState.player && gameState.player.element) {
                 const minimapX = (gameState.player.x / MAP_WIDTH_PX) * minimapWidth - minimapPlayer.offsetWidth / 2;
                 const minimapY = (gameState.player.y / MAP_HEIGHT_PX) * minimapHeight - minimapPlayer.offsetHeight / 2;
                 minimapPlayer.style.left = `${minimapX}px`;
                 minimapPlayer.style.top = `${minimapY}px`;
                 minimapPlayer.style.display = 'block';
             } else {
                 minimapPlayer.style.display = 'none';
             }

            gameState.ai.forEach((ai, index) => {
                const dot = gameState.minimapAIDots[index];
                if (ai && dot && ai.element) {
                     const minimapX = (ai.x / MAP_WIDTH_PX) * minimapWidth - dot.offsetWidth / 2;
                     const minimapY = (ai.y / MAP_HEIGHT_PX) * minimapHeight - dot.offsetHeight / 2;
                     dot.style.left = `${minimapX}px`;
                     dot.style.top = `${minimapY}px`;
                     dot.style.display = 'block';
                } else if (dot) {
                     dot.style.display = 'none';
                }
            });
            updateMinimapStorm();
        }

        function updateMinimapStorm() {
            const minimapWidth = minimapContainer.offsetWidth;
            const minimapHeight = minimapContainer.offsetHeight;
            if (minimapWidth <= 0 || minimapHeight <= 0) return;

            const minimapRadius = (gameState.stormRadius / MAP_WIDTH_PX) * minimapWidth;
            const minimapCenterX = (gameState.stormCenterX / MAP_WIDTH_PX) * minimapWidth;
            const minimapCenterY = (gameState.stormCenterY / MAP_HEIGHT_PX) * minimapHeight;

            minimapStorm.style.width = `${minimapRadius * 2}px`;
            minimapStorm.style.height = `${minimapRadius * 2}px`;
            minimapStorm.style.left = `${minimapCenterX - minimapRadius}px`;
            minimapStorm.style.top = `${minimapCenterY - minimapRadius}px`;
        }

         function showEndScreen(message) {
             messageText.textContent = message;
             messageScreen.style.display = 'flex';
         }
         function hideEndScreen() {
             messageScreen.style.display = 'none';
         }

        let animationFrameId = null;
        function gameLoop(timestamp) {
            if (!gameState || gameState.gameOver) {
                 if (animationFrameId) cancelAnimationFrame(animationFrameId);
                 return;
            }
            if (!gameState.lastTimestamp || gameState.lastTimestamp <= 0) {
                 gameState.lastTimestamp = timestamp - 16;
             }
            gameState.deltaTime = (timestamp - gameState.lastTimestamp) / 1000;
            gameState.lastTimestamp = timestamp;

            if (gameState.deltaTime > 0.1) gameState.deltaTime = 0.1;
            const dt = gameState.deltaTime > 0 ? gameState.deltaTime : 0.001;
            const dt_ms = dt * 1000;
            gameState.gameTime += dt_ms;

            updateAI(dt);
            updatePlayer(dt);
            updateProjectiles(dt);
            updateHealthKitUsage(dt_ms);
            updateStorm(dt);

            updatePlayerCountUI();
            updateMinimap();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        document.addEventListener('DOMContentLoaded', () => {
            try {
                initGame();
            } catch (error) {
                console.error("Error during game initialization:", error);
                 const errorDiv = document.createElement('div');
                 errorDiv.style.color = 'red'; errorDiv.style.position = 'absolute';
                 errorDiv.style.top = '50%'; errorDiv.style.left = '50%';
                 errorDiv.style.transform = 'translate(-50%, -50%)';
                 errorDiv.style.backgroundColor = 'rgba(0,0,0,0.8)';
                 errorDiv.style.padding = '20px'; errorDiv.style.border = '2px solid red';
                 errorDiv.textContent = `Fatal Error Initializing Game. Check console (F12). Error: ${error.message}`;
                 document.body.appendChild(errorDiv);
                  if(gameContainer) gameContainer.style.display = 'none';
                  if(uiContainer) uiContainer.style.display = 'none';
                  if(minimapContainer) minimapContainer.style.display = 'none';
            }
        });
    </script>
</body>
</html>