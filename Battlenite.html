<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MiniRoyale</title>
    <style>
        /* Basic Reset & Body Styling */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #333;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }

        /* Game Container */
        #game-container {
            position: relative;
            /* Set dimensions dynamically via JS based on map size */
            overflow: hidden;
            background-color: #5a8a5a; /* Default grass color */
            border: 2px solid #000;
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        /* Map Tiles */
        .tile {
             position: absolute;
             /* size set by JS */
             z-index: 0; /* Ensure tiles are behind everything else */
             box-sizing: border-box; /* Include border in size */
             /* border: 1px dotted #eee; */ /* Optional: for debugging tile layout */
        }
        .tile-grass { background-color: #5a8a5a; }
        .tile-sand { background-color: #f0e68c; } /* Beach */
        .tile-water { background-color: #4682b4; } /* Ocean */
        /* Forest/Rocky removed as explicit tiles, now treated as obstacles */

        /* Ensure game container default matches grass */
        #game-container {
            /* ... other styles ... */
            background-color: #5a8a5a; /* Default grass color */
        }


        /* Entities (Player, AI) */
        .entity {
            position: absolute;
            /* size set by JS */
            border-radius: 50%; /* Circle shape */
            border: 1px solid #000;
            box-sizing: border-box;
            z-index: 10;
            transition: transform 0.05s linear; /* Smooth rotation */
        }
        .player {
            background-color: #007bff; /* Blue */
        }
        .ai {
            background-color: #dc3545; /* Red */
        }
        .entity::after { /* Direction indicator */
            content: '';
            position: absolute;
            width: 40%;
            height: 3px;
            background-color: #000;
            top: 50%;
            left: 50%;
            transform: translate(0, -50%); /* Center vertically, offset horizontally */
        }

        /* Health Bar (Above Entities) */
        .health-bar {
            position: absolute;
            bottom: 110%; /* Position above the entity */
            left: 50%;
            transform: translateX(-50%);
            width: 30px; /* Fixed width */
            height: 5px;
            background-color: #ccc;
            border: 1px solid #000;
            z-index: 11;
        }
        .health-bar-inner {
            height: 100%;
            background-color: #28a745; /* Green */
            width: 100%; /* Starts full */
            transition: width 0.1s linear;
        }

        /* Obstacles */
        .obstacle {
            position: absolute;
            background-color: #696969; /* Grey */
            border: 1px solid #000;
            z-index: 5;
        }
        .bush {
            background-color: #556b2f; /* Dark Olive Green */
            opacity: 0.8;
            border-radius: 30%;
            z-index: 6; /* Bushes above ground obstacles */
        }
         .wall {
             background-color: #a0522d; /* Sienna */
             z-index: 5;
         }


        /* Chests */
        .chest {
            position: absolute;
            background-color: #ffd700; /* Gold */
            border: 1px solid #8b4513; /* Brown border */
            width: 20px;
            height: 20px;
            z-index: 7;
            cursor: pointer; /* Indicate interactable */
        }

        /* Items */
        .item {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 1px solid #000;
            z-index: 8;
        }
        .item-weapon-ar { background-color: #ff7f50; } /* Coral */
        .item-weapon-smg { background-color: #add8e6; } /* Light Blue */
        .item-weapon-shotgun { background-color: #90ee90; } /* Light Green */
        .item-healthkit { background-color: #f08080; } /* Light Coral */

        /* Projectiles */
        .projectile {
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: #ffeb3b; /* Yellow */
            border-radius: 50%;
            z-index: 9;
            pointer-events: none; /* Don't interfere with mouse clicks */
        }

        /* Storm */
        #storm-circle {
            position: absolute;
            border: 5px dashed rgba(138, 43, 226, 0.6); /* Purple, semi-transparent */
            border-radius: 50%;
            box-sizing: border-box;
            pointer-events: none; /* Don't block clicks */
            z-index: 20;
            /* Size and position set by JS */
             /* Add a visual effect for being outside */
            box-shadow: 0 0 0 5000px rgba(138, 43, 226, 0.15); /* Outer shadow */
        }


        /* UI Elements */
        #ui-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none; /* Allow clicks to pass through UI background */
            z-index: 30;
            color: #fff;
            text-shadow: 1px 1px 2px black;
        }
        #ui-left, #ui-right, #ui-center {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            pointer-events: auto; /* Re-enable pointer events for buttons inside */
        }
         #ui-center {
             position: absolute;
             bottom: 10px; /* Align with others */
             left: 50%;
             transform: translateX(-50%);
         }

        #health-bar-ui {
            width: 150px;
            height: 20px;
            background-color: #ccc;
            border: 1px solid #000;
            margin-bottom: 5px;
        }
        #health-bar-ui-inner {
            height: 100%;
            background-color: #28a745; /* Green */
            width: 100%;
            transition: width 0.1s linear;
        }
        #weapon-info, #health-kit-info, #player-count, #storm-timer {
             margin-top: 5px;
             font-size: 14px;
        }

        /* Minimap */
        #minimap-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px; /* Example size */
            height: 150px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            overflow: hidden;
            z-index: 30;

        }
        #minimap-player {
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: #007bff; /* Player color */
            border-radius: 50%;
            /* Position updated by JS */
        }
        #minimap-storm {
             position: absolute;
             border: 1px dashed rgba(138, 43, 226, 0.8);
             border-radius: 50%;
             /* Size and position updated by JS */
        }
         /* Add dots for AI on minimap if desired */
         .minimap-ai {


            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #dc3545; /* AI color */
            border-radius: 50%;
            /* Position updated by JS */

         }



        /* Touch Controls */
        #touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px; /* Area for controls */
            z-index: 25;
            pointer-events: none; /* Container doesn't block */
            display: none; /* Hidden by default, shown on touch devices */
        }
        #joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto; /* Enable touch */
        }
        #joystick-thumb {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Thumb doesn't block area */
        }
        #shoot-button {
            position: absolute;
            bottom: 35px; /* Adjusted position */
            right: 35px; /* Adjusted position */
            width: 80px;
            height: 80px;
            background-color: rgba(255, 80, 80, 0.5);
            border-radius: 50%;
            pointer-events: auto; /* Enable touch */
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
        }
         #health-kit-button {
             position: absolute;
             bottom: 130px; /* Position above shoot */
             right: 45px;
             width: 60px;
             height: 60px;
             background-color: rgba(80, 255, 80, 0.5);
             border-radius: 50%;
             pointer-events: auto; /* Enable touch */
             display: flex;
             justify-content: center;
             align-items: center;
             color: white;
             font-size: 12px;
             text-align: center;
         }

        /* Game Over / Win Screen */
        #message-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-size: 2em;
            z-index: 50;
        }
         #message-screen button {
             margin-top: 20px;
             padding: 10px 20px;
             font-size: 0.8em;
         }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- Dynamic elements (player, AI, items, etc.) will be added here by JS -->
        <div id="storm-circle"></div>
    </div>

    <div id="ui-container">
        <div id="ui-left">
            <div id="health-bar-ui"><div id="health-bar-ui-inner"></div></div>
            <div id="health-kit-info">Health Kits: 0</div>
        </div>
        <div id="ui-center">
            <div id="storm-timer">Storm: Preparing...</div>
            <div id="player-count">Players Left: 11</div>
        </div>
        <div id="ui-right">
             <div id="weapon-info">Weapon: None</div>
             <!-- Ammo would go here if implemented -->
        </div>
    </div>

    <div id="minimap-container">
        <div id="minimap-player"></div>
        <div id="minimap-storm"></div>
        <!-- AI dots will be added here by JS -->
    </div>

    <div id="touch-controls">
        <div id="joystick-area">
            <div id="joystick-thumb"></div>
        </div>
        <button id="shoot-button">SHOOT</button>
        <button id="health-kit-button">USE KIT</button>
    </div>

    <div id="message-screen">
        <div id="message-text"></div>
        <button id="restart-button">Play Again</button>
    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const uiContainer = document.getElementById('ui-container');
        const healthBarUiInner = document.getElementById('health-bar-ui-inner');
        const weaponInfo = document.getElementById('weapon-info');
        const healthKitInfo = document.getElementById('health-kit-info');
        const playerCount = document.getElementById('player-count');
        const stormTimer = document.getElementById('storm-timer');
        const stormCircle = document.getElementById('storm-circle');
        const minimapContainer = document.getElementById('minimap-container');
        const minimapPlayer = document.getElementById('minimap-player');
        const minimapStorm = document.getElementById('minimap-storm');
        const messageScreen = document.getElementById('message-screen');
        const messageText = document.getElementById('message-text');
        const restartButton = document.getElementById('restart-button');

        // --- AI Constants ---
        const AI_CHEST_SEARCH_RADIUS = 450; // How far AI looks for chests
        const AI_ENEMY_SEARCH_RADIUS = 400; // How far AI looks for enemies
        const AI_CHEST_INTERACT_DIST = 25;  // How close AI needs to be to 'open' a chest
        const AI_STUCK_THRESHOLD = 0.75; // Seconds before attempting to unstick AI
        const AI_UNSTICK_FORCE = 8; // Pixels to nudge when stuck

        // --- Map Generation Constants ---
        const OCEAN_BORDER_TILES = 3; // How many tiles thick the ocean is
        const BEACH_BORDER_TILES = 2; // How many tiles thick the beach is


        // --- Touch Controls ---
        const touchControls = document.getElementById('touch-controls');
        const joystickArea = document.getElementById('joystick-area');
        const joystickThumb = document.getElementById('joystick-thumb');
        const shootButton = document.getElementById('shoot-button');
        const healthKitButton = document.getElementById('health-kit-button');

        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickCurrentX = 0;
        let joystickCurrentY = 0;
        let touchShootActive = false;
        let touchUseKitActive = false;
        const MAX_JOYSTICK_DIST = 30; // Max pixels the thumb can move from center

        // --- Game Constants ---
        const TILE_SIZE = 40; // Pixel size of a grid tile
        const MAP_WIDTH_TILES = 40;
        const MAP_HEIGHT_TILES = 40;
        const MAP_WIDTH_PX = MAP_WIDTH_TILES * TILE_SIZE;
        const MAP_HEIGHT_PX = MAP_HEIGHT_TILES * TILE_SIZE;
        const PLAYER_SIZE = 20;
        const AI_SIZE = 20;
        const PLAYER_SPEED = 150; // Pixels per second
        const AI_SPEED = 120;
        const PROJECTILE_SIZE = 5;
        const PROJECTILE_SPEED = 400;
        const CHEST_SIZE = 20;
        const ITEM_SIZE = 15;
        const MAX_HEALTH = 100;
        const MAX_HEALTH_KITS = 3;
        const HEALTH_KIT_HEAL_AMOUNT = 50;
        const HEALTH_KIT_USE_TIME = 1000; // ms
        const OBSTACLE_MIN_SIZE = TILE_SIZE * 0.8;
        const OBSTACLE_MAX_SIZE = TILE_SIZE * 2.5;
        const BUSH_SIZE = TILE_SIZE * 1.5;
        const WALL_THICKNESS = 10;
        const WALL_MIN_LENGTH = TILE_SIZE * 2;
        const WALL_MAX_LENGTH = TILE_SIZE * 6;
        const MAX_NEARBY_WALLS_FOR_SPAWN = 2; // Reject spawn if >= this many walls are close
        const WALL_CHECK_RADIUS = TILE_SIZE * 1.5; // How far to check for nearby walls

        const WEAPONS = {
            'AR': { name: 'AR', damage: 15, range: 400, fireRate: 150, projectileSpeed: 500, color: '#ff7f50' },
            'SMG': { name: 'SMG', damage: 8, range: 250, fireRate: 70, projectileSpeed: 600, color: '#add8e6' },
            'Shotgun': { name: 'Shotgun', damage: 25, range: 150, fireRate: 800, projectileSpeed: 350, pellets: 5, spread: 0.4, color: '#90ee90' }, // radians spread
        };

        const STORM_PHASES = [
            // Phase 0: Initial state before first shrink
            { waitDuration: 90, shrinkDuration: 60, radiusFraction: 0.8, damage: 1 }, // Wait 90s, then 60s shrink
            // Phase 1: After first shrink completes
            { waitDuration: 60, shrinkDuration: 45, radiusFraction: 0.6, damage: 2 }, // Wait 60s, then 45s shrink
            // Phase 2
            { waitDuration: 45, shrinkDuration: 30, radiusFraction: 0.4, damage: 5 }, // Wait 45s, then 30s shrink
            // Phase 3
            { waitDuration: 30, shrinkDuration: 30, radiusFraction: 0.2, damage: 8 }, // Wait 30s, then 30s shrink
            // Phase 4
            { waitDuration: 30, shrinkDuration: 30, radiusFraction: 0.1, damage: 10 },// Wait 30s, then 30s shrink
            // Phase 5 (Final circle, constant damage, no more shrinking)
            { waitDuration: Infinity, shrinkDuration: 0, radiusFraction: 0.1, damage: 15}
        ];

        // --- Game State ---
        let gameState = {
            player: null,
            ai: [],
            projectiles: [],
            items: [],
            chests: [],
            obstacles: [], // Includes bushes and walls
            mapGrid: [], // Optional: Can store terrain type per tile
            keysDown: {},
            mousePos: { x: 0, y: 0 },
            isMouseDown: false,
            gameTime: 0,
            lastTimestamp: 0,
            deltaTime: 0,
            currentStormPhase: -1, // Starts before phase 0
            stormRadius: MAP_WIDTH_PX, // Initial large radius
            stormCenterX: MAP_WIDTH_PX / 2,
            stormCenterY: MAP_HEIGHT_PX / 2,
            nextStormRadius: MAP_WIDTH_PX,
            nextStormCenterX: MAP_WIDTH_PX / 2,
            nextStormCenterY: MAP_HEIGHT_PX / 2,

            stormTimer: STORM_PHASES[0].waitDuration, // <-- Use waitDuration
            isStormShrinking: false,

            gameOver: false,
            minimapAIDots: [], // Store refs to AI minimap dots
            isUsingHealthKit: false,
            healthKitUseTimer: 0,
        };

        // --- Utility Functions ---
        function getRandom(min, max) {
            return Math.random() * (max - min) + min;
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function checkCollision(rect1, rect2) {
            // Ensure rects have width and height properties
            if (rect1.width === undefined || rect1.height === undefined || rect2.width === undefined || rect2.height === undefined) {
                console.warn("Collision check with undefined width/height:", rect1, rect2);
                return false;
            }
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }


        function getDistance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        // --- Entity Class (Restored Constructor) ---
        class Entity {
            constructor(x, y, size, color, type = 'entity') {
                // --- CORE PROPERTIES ---
                this.x = x;
                this.y = y;
                this.size = size;
                this.width = size; // For collision checks
                this.height = size; // For collision checks
                this.vx = 0; // Velocity x
                this.vy = 0; // Velocity y
                this.angle = 0; // Radians
                this.health = MAX_HEALTH;
                this.maxHealth = MAX_HEALTH;
                this.type = type; // 'player' or 'ai'

                // --- DOM ELEMENTS ---
                this.element = document.createElement('div');
                this.element.classList.add('entity', type);
                this.element.style.width = `${size}px`;
                this.element.style.height = `${size}px`;
                this.element.style.backgroundColor = color;
                this.element.style.left = `${this.x - size / 2}px`; // Use assigned this.x
                this.element.style.top = `${this.y - size / 2}px`;  // Use assigned this.y

                this.healthBarElement = document.createElement('div');
                this.healthBarElement.classList.add('health-bar');
                this.healthBarInnerElement = document.createElement('div');
                this.healthBarInnerElement.classList.add('health-bar-inner');
                this.healthBarElement.appendChild(this.healthBarInnerElement);

                // Append elements AFTER they are created and configured
                gameContainer.appendChild(this.element);
                gameContainer.appendChild(this.healthBarElement);
                // --- END DOM ELEMENTS ---

                // --- OTHER PROPERTIES ---
                this.lastShotTime = 0;
                this.weapon = null;
                this.isHiding = false; // If inside a bush

                // --- AI-SPECIFIC PROPERTIES ---
                this.aiTarget = null; // Reference to the current enemy target
                this.aiReactionTime = type === 'ai' ? getRandom(0.2, 0.6) : 0; // Seconds delay before first shot
                this.aiAimStartTime = 0; // Timestamp when aiming started
                this.aiIsAiming = false; // Is the AI currently aiming (delay timer running)?
                this.aiInaccuracy = type === 'ai' ? getRandom(0.03, 0.1) : 0; // Radians of inaccuracy
                this.aiLastPosition = { x: this.x, y: this.y }; // For stuck detection (use assigned this.x/y)
                this.aiTimeStuck = 0; // For stuck detection

                 // --- NEW Wander Properties ---
                this.aiWanderTargetX = null;
                this.aiWanderTargetY = null;
                this.aiWanderTimer = 0; // Time left for current wander move
                this.aiState = 'idle'; // Track current AI state ('idle', 'looting', 'engaging', 'fleeing', 'wandering')
                // --- END Wander Properties ---
            }

            update(dt) {
                // Store previous position for collision response
                const prevX = this.x;
                const prevY = this.y;

                // Calculate intended next position
                let nextX = this.x + this.vx * dt;
                let nextY = this.y + this.vy * dt;

                // --- Collision with Map Boundaries (Ocean) ---
                let collidedWithBoundary = false;
                const checkRadius = this.size / 2;
                const boundaryPoints = [
                     { x: nextX - checkRadius, y: nextY - checkRadius }, { x: nextX + checkRadius, y: nextY - checkRadius },
                     { x: nextX - checkRadius, y: nextY + checkRadius }, { x: nextX + checkRadius, y: nextY + checkRadius },
                     { x: nextX + (this.vx > 0 ? checkRadius : (this.vx < 0 ? -checkRadius : 0)), y: nextY },
                     { x: nextX, y: nextY + (this.vy > 0 ? checkRadius : (this.vy < 0 ? -checkRadius : 0))}
                ];

                for (const point of boundaryPoints) {
                     const tileX = Math.floor(point.x / TILE_SIZE);
                     const tileY = Math.floor(point.y / TILE_SIZE);

                     if (gameState.mapGrid[tileY]?.[tileX] === 'ocean') {
                         collidedWithBoundary = true;
                         const currentTileX = Math.floor(this.x / TILE_SIZE);
                         const currentTileY = Math.floor(this.y / TILE_SIZE);

                         if (tileX !== currentTileX && gameState.mapGrid[currentTileY]?.[tileX] === 'ocean') {
                             this.vx = 0; nextX = this.x;
                         }
                         if (tileY !== currentTileY && gameState.mapGrid[tileY]?.[currentTileX] === 'ocean') {
                             this.vy = 0; nextY = this.y;
                         }
                          const finalTileX = Math.floor(nextX / TILE_SIZE);
                          const finalTileY = Math.floor(nextY / TILE_SIZE);
                          if(gameState.mapGrid[finalTileY]?.[finalTileX] === 'ocean') {
                              this.vx = 0; this.vy = 0; nextX = this.x; nextY = this.y;
                          }
                         break;
                     }
                }

                 this.x = nextX;
                 this.y = nextY;

                // --- Collision with Obstacles (Improved Response) ---
                 const entityRect = { x: this.x - this.size / 2, y: this.y - this.size / 2, width: this.size, height: this.size };
                 gameState.obstacles.forEach(obstacle => {
                     if (!obstacle.isBush) {
                         const obstacleRect = { x: obstacle.x, y: obstacle.y, width: obstacle.width, height: obstacle.height };
                         if (checkCollision(entityRect, obstacleRect)) {
                             const overlapX = (this.size / 2 + obstacle.width / 2) - Math.abs(this.x - (obstacle.x + obstacle.width / 2));
                             const overlapY = (this.size / 2 + obstacle.height / 2) - Math.abs(this.y - (obstacle.y + obstacle.height / 2));
                             if (overlapX < overlapY) {
                                 this.x += (this.x < obstacle.x + obstacle.width / 2) ? -overlapX : overlapX;
                                 this.vx = 0;
                             } else {
                                 this.y += (this.y < obstacle.y + obstacle.height / 2) ? -overlapY : overlapY;
                                 this.vy = 0;
                             }
                              entityRect.x = this.x - this.size / 2; // Update rect position after pushback
                              entityRect.y = this.y - this.size / 2;
                         }
                     }
                 });

                 // Final boundary clamp
                 this.x = Math.max(this.size / 2, Math.min(MAP_WIDTH_PX - this.size / 2, this.x));
                 this.y = Math.max(this.size / 2, Math.min(MAP_HEIGHT_PX - this.size / 2, this.y));

                // --- Hiding in Bushes ---
                this.isHiding = false;
                const currentEntityRect = { x: this.x - this.size / 2, y: this.y - this.size / 2, width: this.size, height: this.size };
                gameState.obstacles.forEach(obstacle => {
                   if (obstacle.isBush) {
                       const bushRect = { x: obstacle.x, y: obstacle.y, width: obstacle.width, height: obstacle.height };
                       if (checkCollision(currentEntityRect, bushRect)) {
                          this.isHiding = true;
                       }
                   }
                });

                // --- Update DOM Elements ---
                // Check if elements exist before accessing style (Safety Check)
                if (this.element) {
                    this.element.style.opacity = this.isHiding ? '0.5' : '1';
                    this.element.style.left = `${this.x - this.size / 2}px`;
                    this.element.style.top = `${this.y - this.size / 2}px`;
                    this.element.style.transform = `rotate(${this.angle}rad)`;
                } else {
                    console.error("Entity element missing for:", this);
                }

                // Update Health Bar
                if (this.healthBarElement && this.healthBarInnerElement) {
                    this.healthBarElement.style.left = `${this.x}px`;
                    this.healthBarElement.style.top = `${this.y - this.size / 2 - 10}px`;
                    const healthPercent = Math.max(0, (this.health / this.maxHealth) * 100);
                    this.healthBarInnerElement.style.width = `${healthPercent}%`;
                } else {
                     console.error("Entity health bar elements missing for:", this);
                }
            }


            shoot(targetX, targetY) {
                const now = gameState.gameTime;
                if (!this.weapon || !WEAPONS[this.weapon] || now < this.lastShotTime + WEAPONS[this.weapon].fireRate) {
                    return; // No weapon, weapon data missing, or cooldown active
                }

                this.lastShotTime = now;
                const weapon = WEAPONS[this.weapon];
                let angleToTarget = getAngle(this.x, this.y, targetX, targetY);

                // --- Apply Inaccuracy for AI ---
                if (this.type === 'ai' && this.aiInaccuracy > 0) {
                    angleToTarget += getRandom(-this.aiInaccuracy, this.aiInaccuracy);
                }
                // --- End Inaccuracy ---

                if (weapon.name === 'Shotgun') {
                    for (let i = 0; i < weapon.pellets; i++) {
                        const spreadAngle = angleToTarget + getRandom(-weapon.spread / 2, weapon.spread / 2);
                        createProjectile(this.x, this.y, spreadAngle, weapon, this);
                    }
                } else {
                     createProjectile(this.x, this.y, angleToTarget, weapon, this);
                }
            }

            takeDamage(amount) {
                if (this.health <= 0) return; // Already dead

                this.health -= amount;

                // --- Update Health Bar Visual ---
                // Add safety check
                if (this.healthBarInnerElement) {
                    const healthPercent = Math.max(0, (this.health / this.maxHealth) * 100);
                    this.healthBarInnerElement.style.width = `${healthPercent}%`;
                }
                // --- End Update ---

                if (this.health <= 0) {
                    this.die();
                }

                if (this.type === 'player') {
                    updatePlayerUI(); // Update main UI immediately
                }
            }

            die() {
                console.log(`${this.type} died`);
                 // Remove elements from DOM (with safety checks)
                if (this.element && this.element.parentNode) this.element.parentNode.removeChild(this.element);
                if (this.healthBarElement && this.healthBarElement.parentNode) this.healthBarElement.parentNode.removeChild(this.healthBarElement);

                // Nullify elements to prevent potential errors if accessed after death
                this.element = null;
                this.healthBarElement = null;
                this.healthBarInnerElement = null;

                // Remove from game state arrays
                if (this.type === 'player') {
                     gameState.player = null; // Mark player as dead
                     showEndScreen("Game Over!");
                     gameState.gameOver = true;
                } else if (this.type === 'ai') {
                    const index = gameState.ai.indexOf(this);
                    if (index > -1) {
                        gameState.ai.splice(index, 1);
                        // Remove corresponding minimap dot (with safety checks)
                        if (gameState.minimapAIDots[index] && gameState.minimapAIDots[index].parentNode) {
                           gameState.minimapAIDots[index].parentNode.removeChild(gameState.minimapAIDots[index]);
                        }
                        gameState.minimapAIDots.splice(index, 1);
                    }
                    // Check for win condition
                    if (gameState.ai.length === 0 && gameState.player) {
                       showEndScreen("You Win!");
                       gameState.gameOver = true;
                    }
                }
                updatePlayerCountUI();
            }

            pickupItem(item) {
                 if (!item) return false; // Safety check

                if (item.itemType === 'weapon') {
                    this.weapon = item.weaponType; // e.g., 'AR'
                    if (this.type === 'player') updatePlayerUI();
                    console.log(`${this.type} picked up ${item.weaponType}`);
                } else if (item.itemType === 'healthkit') {
                    // Player-specific logic for health kits
                    if (this.type === 'player') {
                        if (this.healthKits === undefined) this.healthKits = 0; // Initialize if missing

                        if (this.healthKits < MAX_HEALTH_KITS) {
                            this.healthKits++;
                            updatePlayerUI();
                            console.log(`Player picked up Health Kit (${this.healthKits}/${MAX_HEALTH_KITS})`);
                        } else {
                             // Player inventory full
                             return false; // Indicate item was not picked up
                        }
                    } else {
                        // AI doesn't use kits (currently)
                        return false; // Indicate item was not picked up by AI
                    }
                }
                 return true; // Indicate item was picked up
            }
        } // End Entity Class


        // --- Projectile Class ---
        class Projectile {
            constructor(x, y, angle, weaponStats, shooter) {
                this.x = x;
                this.y = y;
                this.size = PROJECTILE_SIZE;
                this.width = PROJECTILE_SIZE;
                this.height = PROJECTILE_SIZE;
                this.speed = weaponStats.projectileSpeed;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.damage = weaponStats.damage;
                this.range = weaponStats.range;
                this.distanceTraveled = 0;
                this.shooter = shooter; // Reference to the entity that shot it

                this.element = document.createElement('div');
                this.element.classList.add('projectile');
                this.element.style.width = `${this.size}px`;
                this.element.style.height = `${this.size}px`;
                this.element.style.left = `${x - this.size / 2}px`;
                this.element.style.top = `${y - this.size / 2}px`;
                gameContainer.appendChild(this.element);
            }

            update(dt) {
                const moveDist = this.speed * dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.distanceTraveled += moveDist;

                // Update DOM
                if (this.element) {
                     this.element.style.left = `${this.x - this.size / 2}px`;
                     this.element.style.top = `${this.y - this.size / 2}px`;
                 }

                // Check range
                if (this.distanceTraveled >= this.range) {
                    this.remove();
                    return true; // Indicate removal
                }

                // Check collision with map bounds (remove if out)
                if (this.x < 0 || this.x > MAP_WIDTH_PX || this.y < 0 || this.y > MAP_HEIGHT_PX) {
                    this.remove();
                    return true;
                }

                 // Check collision with obstacles (remove if hit solid obstacle)
                 const projectileRect = { x: this.x - this.size / 2, y: this.y - this.size / 2, width: this.size, height: this.size };
                 for (const obstacle of gameState.obstacles) {
                     if (!obstacle.isBush) { // Don't collide with bushes
                         const obstacleRect = { x: obstacle.x, y: obstacle.y, width: obstacle.width, height: obstacle.height };
                         if (checkCollision(projectileRect, obstacleRect)) {
                             this.remove();
                             return true;
                         }
                     }
                 }


                // Check collision with entities
                const entitiesToCheck = [gameState.player, ...gameState.ai].filter(e => e && e.health > 0 && e !== this.shooter); // Check player and living AI, except the shooter
                for (const entity of entitiesToCheck) {
                    const entityRect = { x: entity.x - entity.size / 2, y: entity.y - entity.size / 2, width: entity.size, height: entity.size };
                    if (checkCollision(projectileRect, entityRect)) {
                        entity.takeDamage(this.damage);
                        this.remove();
                        return true; // Hit! Remove projectile
                    }
                }

                return false; // Still active
            }

            remove() {
                 if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                 }
                 this.element = null; // Prevent further access
                 // Remove from game state array (handled in main loop)
            }
        }

        // --- Item Class ---
        class Item {
            constructor(x, y, itemType, weaponType = null) {
                this.x = x;
                this.y = y;
                this.size = ITEM_SIZE;
                this.width = ITEM_SIZE;
                this.height = ITEM_SIZE;
                this.itemType = itemType; // 'weapon' or 'healthkit'
                this.weaponType = weaponType; // 'AR', 'SMG', 'Shotgun' if itemType is 'weapon'

                this.element = document.createElement('div');
                this.element.classList.add('item');
                this.element.style.width = `${this.size}px`;
                this.element.style.height = `${this.size}px`;
                this.element.style.left = `${x - this.size / 2}px`;
                this.element.style.top = `${y - this.size / 2}px`;

                if (itemType === 'weapon' && weaponType) { // Check weaponType exists
                     this.element.classList.add(`item-weapon-${weaponType.toLowerCase()}`);
                } else if (itemType === 'healthkit') {
                    this.element.classList.add('item-healthkit');
                } else if (itemType === 'weapon' && !weaponType) {
                    console.warn("Created weapon item without weaponType:", x, y);
                    // Maybe add a default appearance?
                }


                gameContainer.appendChild(this.element);
            }

            remove() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
                this.element = null; // Prevent further access
                // Removal from gameState.items handled in main loop
            }
        }

         // --- Chest Class ---
         class Chest {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = CHEST_SIZE;
                 this.width = CHEST_SIZE;
                 this.height = CHEST_SIZE;
                this.opened = false;

                this.element = document.createElement('div');
                this.element.classList.add('chest');
                this.element.style.width = `${this.size}px`;
                this.element.style.height = `${this.size}px`;
                 // Center the chest div on the grid point
                this.element.style.left = `${x - this.size / 2}px`;
                this.element.style.top = `${y - this.size / 2}px`;

                gameContainer.appendChild(this.element);

                // Add event listener for player interaction (e.g., click or proximity)
                // For simplicity, we'll use proximity check in the player update loop
            }

            open() {
                if (this.opened) return;
                this.opened = true;
                if (this.element && this.element.parentNode) this.element.parentNode.removeChild(this.element);
                this.element = null; // Prevent further access

                // Spawn loot
                const numItems = getRandomInt(1, 2); // Drop 1 or 2 items
                const weaponChoices = Object.keys(WEAPONS);
                for (let i = 0; i < numItems; i++) {
                    let itemType = 'weapon';
                     let weaponType = null;
                     // 30% chance for health kit if dropping 2 items, otherwise weapon
                     if(i > 0 && Math.random() < 0.3) {
                         itemType = 'healthkit';
                     } else {
                         if (weaponChoices.length > 0) {
                            weaponType = weaponChoices[getRandomInt(0, weaponChoices.length - 1)];
                         } else {
                            console.warn("No weapons defined in WEAPONS constant to spawn from chest.");
                            continue; // Skip creating this item if no weapons exist
                         }
                     }

                    // Spawn item slightly offset from chest center
                    const spawnX = this.x + getRandom(-15, 15);
                    const spawnY = this.y + getRandom(-15, 15);
                    const newItem = new Item(spawnX, spawnY, itemType, weaponType);
                    gameState.items.push(newItem);
                }
                 // Remove chest from gameState.chests (handled elsewhere, e.g. player/ai update)
            }
         }

         // --- Obstacle Function (using simple objects) ---
         function createObstacle(x, y, width, height, isBush = false, isWall = false) {
             const obstacle = {
                 x, y, width, height, isBush, isWall,
                 element: document.createElement('div')
             };
             obstacle.element.classList.add('obstacle');
             if (isBush) obstacle.element.classList.add('bush');
             if (isWall) obstacle.element.classList.add('wall');
             obstacle.element.style.left = `${x}px`;
             obstacle.element.style.top = `${y}px`;
             obstacle.element.style.width = `${width}px`;
             obstacle.element.style.height = `${height}px`;
             gameContainer.appendChild(obstacle.element);
             return obstacle;
         }


         function initGame() {
            console.log("Initializing game...");
            // Reset state
             gameState = {
                player: null,
                ai: [],
                projectiles: [],
                items: [],
                chests: [],
                obstacles: [],
                mapGrid: [],
                keysDown: {},
                mousePos: { x: 0, y: 0 },
                isMouseDown: false,
                gameTime: 0,
                lastTimestamp: 0,
                deltaTime: 0,
                currentStormPhase: -1,
                stormRadius: Math.max(MAP_WIDTH_PX, MAP_HEIGHT_PX) * 1.5, // Start larger
                stormCenterX: MAP_WIDTH_PX / 2,
                stormCenterY: MAP_HEIGHT_PX / 2,
                nextStormRadius: Math.max(MAP_WIDTH_PX, MAP_HEIGHT_PX) * 1.5,
                nextStormCenterX: MAP_WIDTH_PX / 2,
                nextStormCenterY: MAP_HEIGHT_PX / 2,
                stormTimer: STORM_PHASES[0].waitDuration, // Corrected timer init
                isStormShrinking: false,
                gameOver: false,
                minimapAIDots: [],
                isUsingHealthKit: false,
                healthKitUseTimer: 0,
            };

            // Clear previous elements
            gameContainer.innerHTML = ''; // Clear game area
            minimapContainer.innerHTML = ''; // Clear minimap area

             // Re-add persistent elements
             gameContainer.appendChild(stormCircle); // Add storm first
             minimapContainer.appendChild(minimapPlayer);
             minimapContainer.appendChild(minimapStorm);


             // Re-initialize storm circle style based on initial state
             stormCircle.style.width = `${gameState.stormRadius * 2}px`;
             stormCircle.style.height = `${gameState.stormRadius * 2}px`;
             stormCircle.style.left = `${gameState.stormCenterX - gameState.stormRadius}px`;
             stormCircle.style.top = `${gameState.stormCenterY - gameState.stormRadius}px`;

             // Reset minimap element styles
             minimapPlayer.style.left = '0px'; minimapPlayer.style.top = '0px';
             minimapStorm.style.width = '0px'; minimapStorm.style.height = '0px';


            // Set Game Container Size
            gameContainer.style.width = `${MAP_WIDTH_PX}px`;
            gameContainer.style.height = `${MAP_HEIGHT_PX}px`;

            // --- Create Map Grid and Visual Tiles ---
            console.log("Generating map grid...");
            const mapTilesContainer = document.createElement('div'); // Container for tiles
            mapTilesContainer.id = 'map-tiles';
            mapTilesContainer.style.position = 'absolute';
            mapTilesContainer.style.width = '100%';
            mapTilesContainer.style.height = '100%';
            mapTilesContainer.style.zIndex = 0; // Ensure tiles are behind
            gameContainer.appendChild(mapTilesContainer);

            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                gameState.mapGrid[y] = [];
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    let tileType = 'grass';
                    if (x < OCEAN_BORDER_TILES || x >= MAP_WIDTH_TILES - OCEAN_BORDER_TILES ||
                        y < OCEAN_BORDER_TILES || y >= MAP_HEIGHT_TILES - OCEAN_BORDER_TILES) {
                        tileType = 'ocean';
                    } else if (x < OCEAN_BORDER_TILES + BEACH_BORDER_TILES || x >= MAP_WIDTH_TILES - OCEAN_BORDER_TILES - BEACH_BORDER_TILES ||
                             y < OCEAN_BORDER_TILES + BEACH_BORDER_TILES || y >= MAP_HEIGHT_TILES - OCEAN_BORDER_TILES - BEACH_BORDER_TILES) {
                        tileType = 'sand';
                    }
                    gameState.mapGrid[y][x] = tileType;
                    const tileElement = document.createElement('div');
                    tileElement.classList.add('tile');
                    tileElement.classList.add(tileType === 'ocean' ? 'tile-water' : tileType === 'sand' ? 'tile-sand' : 'tile-grass');
                    tileElement.style.width = `${TILE_SIZE}px`; tileElement.style.height = `${TILE_SIZE}px`;
                    tileElement.style.left = `${x * TILE_SIZE}px`; tileElement.style.top = `${y * TILE_SIZE}px`;
                    mapTilesContainer.appendChild(tileElement);
                }
            }
             console.log("Map grid generated.");

            // --- Helper function for checking spawn validity ---
            function isSpawnLocationValid(x, y, size, checkWalls = true) {
                 if (x - size / 2 < 0 || x + size / 2 > MAP_WIDTH_PX || y - size / 2 < 0 || y + size / 2 > MAP_HEIGHT_PX) return false;

                 const pointsToCheck = [ { cx: x - size / 2, cy: y - size / 2 }, { cx: x + size / 2, cy: y - size / 2 }, { cx: x - size / 2, cy: y + size / 2 }, { cx: x + size / 2, cy: y + size / 2 }, { cx: x, cy: y } ];
                 for (const point of pointsToCheck) {
                    const tileX = Math.floor(point.cx / TILE_SIZE); const tileY = Math.floor(point.cy / TILE_SIZE);
                    if (gameState.mapGrid[tileY]?.[tileX] === 'ocean') return false;
                 }

                 const entityRect = { x: x - size / 2, y: y - size / 2, width: size, height: size };
                 let nearbyWallCount = 0;
                 for (const obs of gameState.obstacles) {
                    if (!obs.isBush) {
                        const obstacleRect = { x: obs.x, y: obs.y, width: obs.width, height: obs.height };
                        if (checkCollision(entityRect, obstacleRect)) return false;
                        if (checkWalls && obs.isWall) {
                            const obsCenterX = obs.x + obs.width / 2; const obsCenterY = obs.y + obs.height / 2;
                            if (getDistance(x, y, obsCenterX, obsCenterY) < WALL_CHECK_RADIUS) nearbyWallCount++;
                        }
                    }
                 }
                 if (checkWalls && nearbyWallCount >= MAX_NEARBY_WALLS_FOR_SPAWN) return false;
                 return true;
            }


            // --- Place Obstacles, Bushes, Walls ---
            console.log("Placing obstacles...");
             const NUM_OBSTACLES = 50; const NUM_BUSHES = 30; const NUM_WALL_STRUCTURES = 5;
             // Place random obstacles
             for (let i = 0; i < NUM_OBSTACLES; i++) {
                 let obsX, obsY, obsSize, validObsSpawn; let attempts = 0;
                 do {
                     obsSize = getRandom(OBSTACLE_MIN_SIZE, OBSTACLE_MAX_SIZE);
                     const minSpawnX = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE; const maxSpawnX = MAP_WIDTH_PX - minSpawnX - obsSize;
                     const minSpawnY = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE; const maxSpawnY = MAP_HEIGHT_PX - minSpawnY - obsSize;
                     if(maxSpawnX <= minSpawnX || maxSpawnY <= minSpawnY) { validObsSpawn = false; break; }
                     obsX = getRandom(minSpawnX, maxSpawnX); obsY = getRandom(minSpawnY, maxSpawnY);
                     validObsSpawn = isSpawnLocationValid(obsX + obsSize / 2, obsY + obsSize / 2, obsSize, false); attempts++;
                 } while (!validObsSpawn && attempts < 50);
                 if (validObsSpawn) gameState.obstacles.push(createObstacle(obsX, obsY, obsSize, obsSize));
             }
             // Place random bushes
             for (let i = 0; i < NUM_BUSHES; i++) {
                let bushX, bushY, validBushSpawn; let attempts = 0; const bushSize = BUSH_SIZE;
                do {
                     const minSpawnX = OCEAN_BORDER_TILES * TILE_SIZE; const maxSpawnX = MAP_WIDTH_PX - minSpawnX - bushSize;
                     const minSpawnY = OCEAN_BORDER_TILES * TILE_SIZE; const maxSpawnY = MAP_HEIGHT_PX - minSpawnY - bushSize;
                     if(maxSpawnX <= minSpawnX || maxSpawnY <= minSpawnY) { validBushSpawn = false; break; }
                     bushX = getRandom(minSpawnX, maxSpawnX); bushY = getRandom(minSpawnY, maxSpawnY);
                     validBushSpawn = isSpawnLocationValid(bushX + bushSize / 2, bushY + bushSize / 2, bushSize, false); attempts++;
                 } while (!validBushSpawn && attempts < 50);
                  if (validBushSpawn) gameState.obstacles.push(createObstacle(bushX, bushY, bushSize, bushSize, true));
             }
             // Place simple wall structures
             for (let i = 0; i < NUM_WALL_STRUCTURES; i++) {
                let attempts = 0; let structurePlaced = false;
                 do {
                     const startX = getRandom(TILE_SIZE * (OCEAN_BORDER_TILES + BEACH_BORDER_TILES + 1), MAP_WIDTH_PX - TILE_SIZE * (OCEAN_BORDER_TILES + BEACH_BORDER_TILES + 1) - WALL_MAX_LENGTH);
                     const startY = getRandom(TILE_SIZE * (OCEAN_BORDER_TILES + BEACH_BORDER_TILES + 1), MAP_HEIGHT_PX - TILE_SIZE * (OCEAN_BORDER_TILES + BEACH_BORDER_TILES + 1) - WALL_MAX_LENGTH);
                     const structureType = getRandomInt(1, 3); // 1=L, 2=U, 3=Rect (Simplified types)
                     let structureValid = isSpawnLocationValid(startX, startY, TILE_SIZE, false); // Basic check

                    if (structureValid) {
                         // Simple Rectangle Structure (Needs robust check for each piece in real game)
                         if (structureType === 3) {
                             const width = getRandom(WALL_MIN_LENGTH, WALL_MAX_LENGTH);
                             const height = getRandom(WALL_MIN_LENGTH, WALL_MAX_LENGTH);
                             // TODO: Add validation checks for ALL wall piece locations here
                             gameState.obstacles.push(createObstacle(startX, startY, width, WALL_THICKNESS, false, true)); // Top
                             gameState.obstacles.push(createObstacle(startX, startY + height - WALL_THICKNESS, width, WALL_THICKNESS, false, true)); // Bottom
                             gameState.obstacles.push(createObstacle(startX, startY + WALL_THICKNESS, WALL_THICKNESS, height - (2*WALL_THICKNESS), false, true)); // Left
                             gameState.obstacles.push(createObstacle(startX + width - WALL_THICKNESS, startY + WALL_THICKNESS, WALL_THICKNESS, height - (2*WALL_THICKNESS), false, true)); // Right
                             structurePlaced = true;
                         }
                         // Add logic for L and U shapes if desired, with proper validation
                    }
                     attempts++;
                 } while (!structurePlaced && attempts < 50);
                 if (!structurePlaced) console.warn("Could not place wall structure", i);
             }
             console.log("Obstacles placed.");


            // --- Spawn Player ---
             console.log("Finding valid player spawn...");
             let playerStartX, playerStartY, validPlayerSpawn; let playerSpawnAttempts = 0; const maxPlayerSpawnAttempts = 100;
             do {
                 const minSpawnX = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE + PLAYER_SIZE / 2; const maxSpawnX = MAP_WIDTH_PX - minSpawnX;
                 const minSpawnY = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE + PLAYER_SIZE / 2; const maxSpawnY = MAP_HEIGHT_PX - minSpawnY;
                 if (maxSpawnX <= minSpawnX || maxSpawnY <= minSpawnY) {
                    console.error("Playable area too small!"); playerStartX = MAP_WIDTH_PX / 2; playerStartY = MAP_HEIGHT_PX / 2; validPlayerSpawn = true; break;
                 }
                 playerStartX = getRandom(minSpawnX, maxSpawnX); playerStartY = getRandom(minSpawnY, maxSpawnY);
                 validPlayerSpawn = isSpawnLocationValid(playerStartX, playerStartY, PLAYER_SIZE, true); playerSpawnAttempts++;
             } while (!validPlayerSpawn && playerSpawnAttempts < maxPlayerSpawnAttempts);
             if (!validPlayerSpawn) {
                 console.warn(`Could not find clear player spawn. Falling back.`);
                 playerStartX = MAP_WIDTH_PX / 2; playerStartY = MAP_HEIGHT_PX / 2; // Simple fallback
             }
             console.log(`Player spawned at (${playerStartX.toFixed(0)}, ${playerStartY.toFixed(0)})`);
             // --- Player Instance Creation ---
             try {
                gameState.player = new Entity(playerStartX, playerStartY, PLAYER_SIZE, '#007bff', 'player');
                gameState.player.healthKits = 0; // Initialize health kits for player
             } catch (error) {
                 console.error("FATAL: Failed to create player entity!", error);
                 // Handle fatal error - maybe show an error message?
                 showEndScreen("Error: Failed to start game.");
                 gameState.gameOver = true; // Stop the game loop if player fails
                 return; // Exit initGame early
             }


            // --- Spawn AI ---
            console.log("Spawning AI...");
            const NUM_AI = 10;
            gameState.minimapAIDots = [];
            for (let i = 0; i < NUM_AI; i++) {
                 let spawnX, spawnY, validSpawn; let attempts = 0;
                 do {
                     const minSpawnX = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE + AI_SIZE / 2; const maxSpawnX = MAP_WIDTH_PX - minSpawnX;
                     const minSpawnY = (OCEAN_BORDER_TILES + BEACH_BORDER_TILES) * TILE_SIZE + AI_SIZE / 2; const maxSpawnY = MAP_HEIGHT_PX - minSpawnY;
                     if (maxSpawnX <= minSpawnX || maxSpawnY <= minSpawnY) { validSpawn = false; break; }
                     spawnX = getRandom(minSpawnX, maxSpawnX); spawnY = getRandom(minSpawnY, maxSpawnY);
                     validSpawn = isSpawnLocationValid(spawnX, spawnY, AI_SIZE, true);
                     if (validSpawn && gameState.player && getDistance(spawnX, spawnY, gameState.player.x, gameState.player.y) < TILE_SIZE * 5) { // Check player exists
                         validSpawn = false;
                     }
                     attempts++;
                 } while (!validSpawn && attempts < 50);

                 if (validSpawn) {
                     try {
                        const ai = new Entity(spawnX, spawnY, AI_SIZE, '#dc3545', 'ai');
                        gameState.ai.push(ai);
                        const aiDot = document.createElement('div');
                        aiDot.classList.add('minimap-ai');
                        minimapContainer.appendChild(aiDot);
                        gameState.minimapAIDots.push(aiDot);
                     } catch (error) {
                         console.error(`Failed to create AI entity ${i}:`, error);
                         // Continue trying to spawn other AI
                     }
                 } else {
                     console.warn("Could not find valid spawn for AI", i);
                 }
             }
             console.log(`AI spawned: ${gameState.ai.length} successfully.`); // Log actual count


            // --- Spawn Chests ---
            console.log("Spawning chests...");
            const NUM_CHESTS = 40;
            for (let i = 0; i < NUM_CHESTS; i++) {
                 let spawnX, spawnY, validSpawn; let attempts = 0;
                 do {
                    const minSpawnX = OCEAN_BORDER_TILES * TILE_SIZE + CHEST_SIZE / 2; const maxSpawnX = MAP_WIDTH_PX - minSpawnX;
                    const minSpawnY = OCEAN_BORDER_TILES * TILE_SIZE + CHEST_SIZE / 2; const maxSpawnY = MAP_HEIGHT_PX - minSpawnY;
                    if (maxSpawnX <= minSpawnX || maxSpawnY <= minSpawnY) { validSpawn = false; break; }
                    spawnX = getRandom(minSpawnX, maxSpawnX); spawnY = getRandom(minSpawnY, maxSpawnY);
                    validSpawn = isSpawnLocationValid(spawnX, spawnY, CHEST_SIZE, true); attempts++;
                 } while (!validSpawn && attempts < 50);
                 if(validSpawn) gameState.chests.push(new Chest(spawnX, spawnY));
                 else console.warn("Could not find valid spawn for Chest", i);
            }
            console.log("Chests spawned.");

            // Check if game should continue after initialization attempts
            if (gameState.gameOver) {
                console.log("Game initialization failed or stopped early.");
                return;
            }

            // Initial UI Update
            updatePlayerUI();
            updatePlayerCountUI();
            updateStormUI();
            hideEndScreen(); // Ensure end screen is hidden

            // Add Event Listeners
            addEventListeners();

            // Start Game Loop
            gameState.lastTimestamp = performance.now();
            if (animationFrameId) cancelAnimationFrame(animationFrameId); // Clear previous frame request
            gameLoop(gameState.lastTimestamp); // Start the loop
            console.log("Game initialized and loop started.");
        } // End initGame

        // --- Event Listeners ---
        function addEventListeners() {
            // Keyboard
            window.addEventListener('keydown', (e) => {
                gameState.keysDown[e.key.toLowerCase()] = true;
                if (e.key.toLowerCase() === 'e' && gameState.player && !gameState.isUsingHealthKit && gameState.player.healthKits > 0) {
                    startUsingHealthKit();
                }
            });
            window.addEventListener('keyup', (e) => {
                gameState.keysDown[e.key.toLowerCase()] = false;
                 if (e.key.toLowerCase() === 'e' || ['w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
                     cancelUsingHealthKit();
                 }
            });

            // Mouse
            window.addEventListener('mousemove', (e) => {
                const rect = gameContainer.getBoundingClientRect();
                if (rect) { // Check if gameContainer exists and has dimensions
                    gameState.mousePos.x = e.clientX - rect.left;
                    gameState.mousePos.y = e.clientY - rect.top;
                }
            });
            window.addEventListener('mousedown', (e) => {
                if (e.button === 0) { gameState.isMouseDown = true; cancelUsingHealthKit(); }
            });
            window.addEventListener('mouseup', (e) => {
                 if (e.button === 0) { gameState.isMouseDown = false; }
            });

            // Touch Controls Setup
            if ('ontouchstart' in window) {
                 touchControls.style.display = 'block';
                 // Joystick
                 joystickArea.addEventListener('touchstart', (e) => {
                     e.preventDefault(); joystickActive = true; const touch = e.touches[0]; const rect = joystickArea.getBoundingClientRect();
                     joystickStartX = rect.left + rect.width / 2; joystickStartY = rect.top + rect.height / 2;
                     joystickCurrentX = touch.clientX; joystickCurrentY = touch.clientY; cancelUsingHealthKit();
                 }, { passive: false });
                 joystickArea.addEventListener('touchmove', (e) => {
                     e.preventDefault(); if (!joystickActive) return; const touch = e.touches[0];
                     joystickCurrentX = touch.clientX; joystickCurrentY = touch.clientY;
                 }, { passive: false });
                 window.addEventListener('touchend', (e) => {
                     let relatedToEnd = false;
                     for(let i=0; i < e.changedTouches.length; i++){
                         const touch = e.changedTouches[i]; const rect = joystickArea.getBoundingClientRect(); // Re-get rect in case of scroll/resize
                         const currentJoystickCenterX = rect.left + rect.width / 2; const currentJoystickCenterY = rect.top + rect.height / 2;
                         const distFromCenter = getDistance(touch.clientX, touch.clientY, currentJoystickCenterX, currentJoystickCenterY);
                         if(distFromCenter < joystickArea.offsetWidth) { relatedToEnd = true; break; } // Check within area bounds
                     }
                     if(joystickActive && relatedToEnd) {
                         joystickActive = false; joystickThumb.style.transform = 'translate(-50%, -50%)';
                     }
                 });
                 // Shoot Button
                 shootButton.addEventListener('touchstart', (e) => { e.preventDefault(); touchShootActive = true; cancelUsingHealthKit(); }, { passive: false });
                 shootButton.addEventListener('touchend', (e) => { e.preventDefault(); touchShootActive = false; });
                 // Health Kit Button
                 healthKitButton.addEventListener('touchstart', (e) => {
                     e.preventDefault();
                     if (gameState.player && !gameState.isUsingHealthKit && gameState.player.healthKits > 0) startUsingHealthKit();
                 }, { passive: false });
            }

            // Restart Button
            restartButton.addEventListener('click', initGame);
        }


        // --- Health Kit Logic ---
        function startUsingHealthKit() {
            if (gameState.isUsingHealthKit || !gameState.player || gameState.player.healthKits <= 0 || gameState.player.health >= MAX_HEALTH) return;

            console.log("Starting to use Health Kit...");
            gameState.isUsingHealthKit = true;
            gameState.healthKitUseTimer = HEALTH_KIT_USE_TIME;
            if (gameState.player.element) gameState.player.element.style.boxShadow = '0 0 10px 5px lightgreen';
            gameState.player.vx = 0; gameState.player.vy = 0; // Stop movement
        }

        function updateHealthKitUsage(dt_ms) {
            if (!gameState.isUsingHealthKit || !gameState.player) return; // Add player check

            gameState.healthKitUseTimer -= dt_ms;

            if (gameState.healthKitUseTimer <= 0) {
                finishUsingHealthKit();
            }
        }

        function finishUsingHealthKit() {
            if (!gameState.isUsingHealthKit || !gameState.player) return;

             console.log("Finished using Health Kit.");
            gameState.player.health = Math.min(MAX_HEALTH, gameState.player.health + HEALTH_KIT_HEAL_AMOUNT);
            gameState.player.healthKits--;
            gameState.isUsingHealthKit = false;
            gameState.healthKitUseTimer = 0;
             if (gameState.player.element) gameState.player.element.style.boxShadow = '';
            updatePlayerUI();
        }

        function cancelUsingHealthKit() {
             if (gameState.isUsingHealthKit) {
                 console.log("Cancelled Health Kit usage.");
                 gameState.isUsingHealthKit = false;
                 gameState.healthKitUseTimer = 0;
                 if(gameState.player && gameState.player.element) gameState.player.element.style.boxShadow = '';
             }
        }


        // --- Update Functions ---
        function updatePlayer(dt) {
            if (!gameState.player || gameState.gameOver || gameState.isUsingHealthKit) return;

            let moveX = 0; let moveY = 0;
            if (gameState.keysDown['w']) moveY -= 1; if (gameState.keysDown['s']) moveY += 1;
            if (gameState.keysDown['a']) moveX -= 1; if (gameState.keysDown['d']) moveX += 1;

            if (joystickActive) {
                const dx = joystickCurrentX - joystickStartX; const dy = joystickCurrentY - joystickStartY;
                const dist = Math.min(MAX_JOYSTICK_DIST, getDistance(0, 0, dx, dy));
                const angle = Math.atan2(dy, dx);
                const clampedDx = Math.cos(angle) * dist; const clampedDy = Math.sin(angle) * dist;
                moveX = clampedDx / MAX_JOYSTICK_DIST; moveY = clampedDy / MAX_JOYSTICK_DIST;
                joystickThumb.style.transform = `translate(calc(-50% + ${clampedDx}px), calc(-50% + ${clampedDy}px))`;
            }

            const moveMagnitude = Math.sqrt(moveX * moveX + moveY * moveY);
            if (moveMagnitude > 1) { // Normalize if magnitude > 1 (necessary for combined inputs)
                moveX /= moveMagnitude; moveY /= moveMagnitude;
            }

            gameState.player.vx = moveX * PLAYER_SPEED;
            gameState.player.vy = moveY * PLAYER_SPEED;
            gameState.player.angle = getAngle(gameState.player.x, gameState.player.y, gameState.mousePos.x, gameState.mousePos.y);

            if (gameState.isMouseDown || touchShootActive) {
                 gameState.player.shoot(gameState.mousePos.x, gameState.mousePos.y);
            }

            gameState.player.update(dt); // Movement, collision, rendering

             // Item Pickup
             const playerRect = { x: gameState.player.x - gameState.player.size / 2, y: gameState.player.y - gameState.player.size / 2, width: gameState.player.size, height: gameState.player.size };
             for (let i = gameState.items.length - 1; i >= 0; i--) {
                 const item = gameState.items[i];
                 if (!item) continue; // Safety check
                 const itemRect = { x: item.x - item.size / 2, y: item.y - item.size / 2, width: item.size, height: item.size };
                 if (checkCollision(playerRect, itemRect)) {
                     if (gameState.player.pickupItem(item)) {
                        item.remove(); gameState.items.splice(i, 1);
                     }
                 }
             }

             // Chest Opening
             const interactDist = gameState.player.size * 1.5;
             for (let i = gameState.chests.length - 1; i >= 0; i--) {
                 const chest = gameState.chests[i];
                 if (chest && !chest.opened) { // Safety check
                      if (getDistance(gameState.player.x, gameState.player.y, chest.x, chest.y) < interactDist) {
                          chest.open();
                          gameState.chests.splice(i, 1); // Remove opened chest
                      }
                 }
             }
        }

        function updateAI(dt) {
            if (gameState.gameOver) return;

            gameState.ai.forEach((ai, aiIndex) => {
                // --- Basic Checks ---
                if (!ai || ai.health <= 0 || !ai.element) {
                    // Clean up minimap dot if AI somehow exists but element doesn't
                    const dot = gameState.minimapAIDots[aiIndex];
                    if (dot && dot.parentNode) dot.parentNode.removeChild(dot);
                    return; // Skip dead or invalid AI
                }

                // --- Reset Per-Frame State ---
                let targetX = null;         // Intended X destination for movement/aiming
                let targetY = null;         // Intended Y destination
                let isShooting = false;     // Should the AI shoot this frame?
                let decidedAction = false; // Flag to prevent lower priority actions once one is chosen
                ai.aiState = 'idle';      // Reset state for this frame's decision

                // === AI Decision Making Priorities ===

                // --- Priority 1: Engage Enemy (Only if AI has a weapon) ---
                if (ai.weapon && !decidedAction) {
                    let closestEnemy = null;
                    let minEnemyDist = AI_ENEMY_SEARCH_RADIUS;
                    const potentialTargets = [gameState.player, ...gameState.ai].filter(e => e && e.health > 0 && e !== ai && e.element); // Include player and other living AI

                    potentialTargets.forEach(enemy => {
                        const dist = getDistance(ai.x, ai.y, enemy.x, enemy.y);
                        if (dist < minEnemyDist && !enemy.isHiding && hasLineOfSight(ai.x, ai.y, enemy.x, enemy.y)) {
                            minEnemyDist = dist;
                            closestEnemy = enemy;
                        }
                    });

                    if (closestEnemy) {
                        ai.aiState = 'engaging';
                        decidedAction = true;
                        targetX = closestEnemy.x; // Aim/move towards the enemy
                        targetY = closestEnemy.y;

                        const weaponRange = WEAPONS[ai.weapon]?.range ?? 0;

                        // Targeting / Reaction Time Logic
                        if (ai.aiTarget !== closestEnemy) { // New target found
                            ai.aiTarget = closestEnemy;
                            ai.aiIsAiming = false;
                            ai.aiAimStartTime = 0;
                            ai.aiWanderTimer = 0; // Stop wandering if enemy spotted
                        }

                        if (minEnemyDist < weaponRange) { // Target in range
                            if (!ai.aiIsAiming) { // Start aiming delay
                                ai.aiIsAiming = true;
                                ai.aiAimStartTime = gameState.gameTime;
                            }
                            const timeSinceAimStart = (gameState.gameTime - ai.aiAimStartTime) / 1000;
                            if (ai.aiIsAiming && timeSinceAimStart >= ai.aiReactionTime) {
                                isShooting = true; // Aim delay complete, shoot!
                                ai.shoot(targetX, targetY);
                            } else {
                                isShooting = false; // Still aiming
                            }
                        } else { // Target visible but out of range
                            isShooting = false;
                            ai.aiIsAiming = false; // Reset aiming if target moves out of range
                            ai.aiAimStartTime = 0;
                        }
                    } else {
                        // No enemy found, reset target state if previous target lost
                        if(ai.aiTarget) {
                             ai.aiTarget = null;
                             ai.aiIsAiming = false;
                             ai.aiAimStartTime = 0;
                        }
                    }
                } // End Priority 1: Engage Enemy

                // --- Priority 2: Seek Loot (Only if AI *doesn't* have a weapon and isn't engaging) ---
                if (!ai.weapon && !decidedAction) {
                    let closestChest = null;
                    let minChestDist = AI_CHEST_SEARCH_RADIUS;

                    gameState.chests.forEach((chest) => {
                        if (chest && !chest.opened) {
                            const dist = getDistance(ai.x, ai.y, chest.x, chest.y);
                            if (dist < minChestDist && hasLineOfSight(ai.x, ai.y, chest.x, chest.y)) {
                                minChestDist = dist;
                                closestChest = chest;
                            }
                        }
                    });

                    if (closestChest) {
                        ai.aiState = 'looting';
                        decidedAction = true;
                        ai.aiWanderTimer = 0; // Stop wandering

                        if (minChestDist < AI_CHEST_INTERACT_DIST) {
                            // Interact with chest (Open and potentially get weapon)
                            closestChest.open(); // AI opens the chest
                            const foundIndex = gameState.chests.indexOf(closestChest);
                            if (foundIndex > -1) gameState.chests.splice(foundIndex, 1);
                            // AI doesn't automatically get weapon here; chest.open spawns items.
                            // AI will try to pick up items in its next update cycle if needed.
                            // OR, simplify: just give AI a random weapon on chest open:
                             const weaponChoices = Object.keys(WEAPONS);
                             if (weaponChoices.length > 0) {
                                ai.weapon = weaponChoices[getRandomInt(0, weaponChoices.length - 1)];
                                // console.log(`AI ${aiIndex} got weapon: ${ai.weapon} from chest`);
                             }
                             targetX = null; // Stop moving briefly while opening
                             targetY = null;
                        } else {
                            // Move towards the chest
                            targetX = closestChest.x;
                            targetY = closestChest.y;
                        }
                    }
                } // End Priority 2: Seek Loot

                // --- Priority 3: Storm Safety (If not engaging or actively looting) ---
                // *All* AI should care about the storm, armed or not
                if (!decidedAction) {
                    const currentDistFromCenter = getDistance(ai.x, ai.y, gameState.stormCenterX, gameState.stormCenterY);
                    const nextDistFromCenter = getDistance(ai.x, ai.y, gameState.nextStormCenterX, gameState.nextStormCenterY);
                    const isOutsideCurrent = currentDistFromCenter > gameState.stormRadius;
                    const isOutsideNext = nextDistFromCenter > gameState.nextStormRadius;

                    if (isOutsideCurrent && gameState.currentStormPhase >= 0) { // If outside current circle (and storm active)
                        ai.aiState = 'fleeing';
                        decidedAction = true;
                        targetX = gameState.stormCenterX; // Head towards the current center
                        targetY = gameState.stormCenterY;
                        ai.aiWanderTimer = 0; // Stop wandering
                    } else if (gameState.isStormShrinking && isOutsideNext) { // If inside current, but outside next, and it's shrinking
                        ai.aiState = 'fleeing';
                        decidedAction = true;
                        targetX = gameState.nextStormCenterX; // Head towards the next center
                        targetY = gameState.nextStormCenterY;
                        ai.aiWanderTimer = 0; // Stop wandering
                    }
                } // End Priority 3: Storm Safety

                 // --- Priority 4: Wander (If safe, armed or no loot nearby, and no enemy) ---
                 if (!decidedAction) {
                     ai.aiState = 'wandering'; // Set state to wandering
                     ai.aiWanderTimer -= dt;

                     if (ai.aiWanderTimer <= 0 || ai.aiWanderTargetX === null) {
                         // Time to pick a new wander target
                         const wanderDist = getRandom(150, 400); // How far to wander
                         const wanderAngle = getRandom(0, Math.PI * 2);
                         let potentialX = ai.x + Math.cos(wanderAngle) * wanderDist;
                         let potentialY = ai.y + Math.sin(wanderAngle) * wanderDist;

                         // --- Validate Wander Target ---
                         // 1. Clamp to map boundaries (generous padding)
                         const padding = TILE_SIZE;
                         potentialX = Math.max(padding, Math.min(MAP_WIDTH_PX - padding, potentialX));
                         potentialY = Math.max(padding, Math.min(MAP_HEIGHT_PX - padding, potentialY));

                         // 2. Check if target is in ocean (simple check)
                         const targetTileX = Math.floor(potentialX / TILE_SIZE);
                         const targetTileY = Math.floor(potentialY / TILE_SIZE);
                         if (gameState.mapGrid[targetTileY]?.[targetTileX] !== 'ocean') {
                             // 3. TODO: Optional - More robust check using isSpawnLocationValid (might be slow)
                             // if (isSpawnLocationValid(potentialX, potentialY, ai.size / 2, false)) {
                                ai.aiWanderTargetX = potentialX;
                                ai.aiWanderTargetY = potentialY;
                                ai.aiWanderTimer = getRandom(4, 8); // Wander for 4-8 seconds
                                // console.log(`AI ${aiIndex} new wander target: ${Math.round(ai.aiWanderTargetX)}, ${Math.round(ai.aiWanderTargetY)}`)
                             // } else { // Invalid wander target, try again next frame
                             //    ai.aiWanderTimer = 0.1; // Short timer to retry quickly
                             // }
                         } else {
                              // Target was in ocean, try again next frame
                             ai.aiWanderTimer = 0.1; // Short timer to retry quickly
                             ai.aiWanderTargetX = null; // Clear target
                             ai.aiWanderTargetY = null;
                         }
                     }

                     // If we have a valid wander target, move towards it
                     if (ai.aiWanderTargetX !== null) {
                         targetX = ai.aiWanderTargetX;
                         targetY = ai.aiWanderTargetY;
                         // If AI gets very close to wander target, pick a new one sooner
                         if (getDistance(ai.x, ai.y, targetX, targetY) < ai.size * 1.5) {
                             ai.aiWanderTimer = 0; // Force new target next frame
                         }
                     }
                 } // End Priority 4: Wander

                // === Action Execution ===

                // --- Update Angle ---
                if (targetX !== null && targetY !== null) {
                    // Smooth angle change? Optional. For now, instant snap.
                    ai.angle = getAngle(ai.x, ai.y, targetX, targetY);
                } else if (ai.aiState === 'idle' || ai.aiState === 'wandering') {
                    // Optional: Slight random angle drift when idle/wandering?
                    // ai.angle += getRandom(-0.05, 0.05) * dt * 10;
                }

                // --- Set Velocity ---
                ai.vx = 0; // Default to not moving
                ai.vy = 0;
                if (!isShooting && targetX !== null && targetY !== null) { // Only move if not shooting and has a target
                    // Check if close enough to target (especially for non-enemy targets)
                    const distToTarget = getDistance(ai.x, ai.y, targetX, targetY);
                    // Don't move if looting and very close, or wandering and very close
                     const stopDistance = (ai.aiState === 'looting' || ai.aiState === 'wandering') ? ai.size : -1; // Only stop for loot/wander

                    if (distToTarget > stopDistance) {
                        const angleToTarget = ai.angle; // Use calculated angle
                        ai.vx = Math.cos(angleToTarget) * AI_SPEED;
                        ai.vy = Math.sin(angleToTarget) * AI_SPEED;
                    }
                }


                // --- Stuck Detection ---
                const intendedMovement = Math.abs(ai.vx) > 0.1 || Math.abs(ai.vy) > 0.1;
                const actualDistMoved = getDistance(ai.x, ai.y, ai.aiLastPosition.x, ai.aiLastPosition.y);

                 // Scale threshold slightly based on delta time to be less sensitive to frame drops
                 const stuckMoveThreshold = 0.5 * dt * 60; // Expect ~0.5px movement per 1/60th sec

                if (intendedMovement && actualDistMoved < stuckMoveThreshold) {
                    ai.aiTimeStuck += dt;
                } else {
                    ai.aiTimeStuck = 0; // Reset timer if moving or not intending to move
                }

                // Update last position *before* the main update call
                ai.aiLastPosition.x = ai.x;
                ai.aiLastPosition.y = ai.y;

                if (ai.aiTimeStuck > AI_STUCK_THRESHOLD) {
                    console.warn(`AI ${aiIndex} stuck! Nudging. State: ${ai.aiState}`);
                    const nudgeAngle = getRandom(0, Math.PI * 2);
                    // Apply nudge velocity for one frame
                    ai.vx = Math.cos(nudgeAngle) * AI_SPEED * 0.6;
                    ai.vy = Math.sin(nudgeAngle) * AI_SPEED * 0.6;

                    ai.aiTimeStuck = 0; // Reset timer after nudging
                    ai.aiIsAiming = false; // Stop aiming if stuck
                    ai.aiAimStartTime = 0;
                    ai.aiWanderTimer = 0.1; // Force new wander target quickly if was wandering
                }
                // --- End Stuck Detection ---


                // --- Final Entity Update (Movement, Collision, Rendering) ---
                ai.update(dt);

            }); // End forEach AI loop
        } // End updateAI function

        // Basic Line of Sight Check
        function hasLineOfSight(x1, y1, x2, y2) {
            const dx = x2 - x1; const dy = y2 - y1; const dist = Math.sqrt(dx * dx + dy * dy);
            const steps = Math.max(1, Math.floor(dist / (TILE_SIZE / 2)));
            for (let i = 1; i <= steps; i++) {
                const checkX = x1 + (dx / steps) * i; const checkY = y1 + (dy / steps) * i;
                const pointRect = { x: checkX - 1, y: checkY - 1, width: 2, height: 2 };
                for (const obstacle of gameState.obstacles) {
                    if (!obstacle.isBush) {
                         const obstacleRect = { x: obstacle.x, y: obstacle.y, width: obstacle.width, height: obstacle.height };
                         if (checkCollision(pointRect, obstacleRect)) return false;
                    }
                }
            }
            return true;
        }


        function updateProjectiles(dt) {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const projectile = gameState.projectiles[i];
                if (projectile) { // Safety check
                    const removed = projectile.update(dt);
                    if (removed) gameState.projectiles.splice(i, 1);
                } else {
                    console.warn("Undefined projectile found in array, removing.");
                    gameState.projectiles.splice(i, 1); // Remove null/undefined entries
                }
            }
        }

        function createProjectile(x, y, angle, weaponStats, shooter) {
             if (!weaponStats) {
                 console.error("Attempted to create projectile with undefined weaponStats", shooter);
                 return;
             }
            const projectile = new Projectile(x, y, angle, weaponStats, shooter);
            gameState.projectiles.push(projectile);
        }

        function updateStorm(dt) {
             if (gameState.gameOver || gameState.currentStormPhase === undefined) return; // Add phase check

             gameState.stormTimer -= dt;

             if (gameState.stormTimer <= 0) {
                 if (!gameState.isStormShrinking) { // Waiting ended -> Start shrinking
                     gameState.currentStormPhase++;
                     const phaseIndex = Math.min(gameState.currentStormPhase, STORM_PHASES.length - 1);
                     const currentPhaseData = STORM_PHASES[phaseIndex];

                     if (!currentPhaseData) { console.error("Missing storm phase data for index:", phaseIndex); return; }

                     if (currentPhaseData.shrinkDuration > 0) {
                        gameState.isStormShrinking = true;
                        gameState.stormTimer = currentPhaseData.shrinkDuration;

                        const mapCenterRadius = Math.min(MAP_WIDTH_PX, MAP_HEIGHT_PX) / 2; // Base size on smaller map dimension
                        const nextRadius = mapCenterRadius * currentPhaseData.radiusFraction;
                        gameState.nextStormRadius = Math.max(5, nextRadius); // Ensure minimum radius

                        const currentRadius = gameState.stormRadius;
                        const maxOffset = Math.max(0, currentRadius - gameState.nextStormRadius);
                        const angle = getRandom(0, Math.PI * 2);
                        const offset = getRandom(0, maxOffset * 0.8);

                        gameState.nextStormCenterX = gameState.stormCenterX + Math.cos(angle) * offset;
                        gameState.nextStormCenterY = gameState.stormCenterY + Math.sin(angle) * offset;

                        // Clamp next center more robustly
                        gameState.nextStormCenterX = Math.max(gameState.nextStormRadius, Math.min(MAP_WIDTH_PX - gameState.nextStormRadius, gameState.nextStormCenterX));
                        gameState.nextStormCenterY = Math.max(gameState.nextStormRadius, Math.min(MAP_HEIGHT_PX - gameState.nextStormRadius, gameState.nextStormCenterY));

                        // console.log(`Storm Phase ${phaseIndex + 1} SHRINK START`);

                     } else { // Final phase reached
                         // console.log(`Storm Phase ${phaseIndex + 1} Final Size`);
                         gameState.stormTimer = Infinity;
                     }

                 } else { // Shrinking ended -> Start waiting
                     gameState.isStormShrinking = false;
                     gameState.stormRadius = gameState.nextStormRadius;
                     gameState.stormCenterX = gameState.nextStormCenterX;
                     gameState.stormCenterY = gameState.nextStormCenterY;

                     const nextPhaseIndex = Math.min(gameState.currentStormPhase + 1, STORM_PHASES.length - 1);
                     const nextPhaseData = STORM_PHASES[nextPhaseIndex];
                     if (!nextPhaseData) { console.error("Missing next storm phase data for index:", nextPhaseIndex); return; }

                     gameState.stormTimer = nextPhaseData.waitDuration;

                     const currentPhaseIndex = Math.min(gameState.currentStormPhase, STORM_PHASES.length - 1);
                    // console.log(`Storm Phase ${currentPhaseIndex + 1} SHRINK END. Wait: ${Math.round(gameState.stormTimer)}s`);
                     if (gameState.stormTimer === Infinity) { /* console.log("Final phase wait started."); */ }
                 }
             } // End timer check

             // Apply Storm Damage
             if (gameState.currentStormPhase >= 0) {
                 const phaseIndex = Math.min(gameState.currentStormPhase, STORM_PHASES.length - 1);
                 const currentPhaseData = STORM_PHASES[phaseIndex];
                 if (currentPhaseData) { // Check data exists
                    const damagePerSecond = currentPhaseData.damage;
                    const entities = [gameState.player, ...gameState.ai].filter(e => e && e.health > 0); // Filter living entities
                    entities.forEach(entity => {
                        const distFromCenter = getDistance(entity.x, entity.y, gameState.stormCenterX, gameState.stormCenterY);
                        if (distFromCenter > gameState.stormRadius) {
                            entity.takeDamage(damagePerSecond * dt);
                        }
                    });
                 }
             }

             updateStormUI();
             updateMinimapStorm();
        } // End updateStorm

        // --- UI Update Functions ---
        function updatePlayerUI() {
            if (!gameState.player) {
                healthBarUiInner.style.width = '0%';
                weaponInfo.textContent = 'Weapon: None';
                healthKitInfo.textContent = 'Health Kits: 0';
                return;
            }
            const healthPercent = Math.max(0, (gameState.player.health / gameState.player.maxHealth) * 100);
            healthBarUiInner.style.width = `${healthPercent}%`;
            weaponInfo.textContent = `Weapon: ${gameState.player.weapon ? (WEAPONS[gameState.player.weapon]?.name ?? 'Unknown') : 'None'}`;
             healthKitInfo.textContent = `Health Kits: ${gameState.player.healthKits ?? 0}`; // Use ?? 0 if undefined
        }

        function updatePlayerCountUI() {
            // Ensure AI array contains valid entities before counting
            const validAICount = gameState.ai.filter(ai => ai && ai.health > 0).length;
            const count = (gameState.player && gameState.player.health > 0 ? 1 : 0) + validAICount;
            playerCount.textContent = `Players Left: ${count}`;
        }


        function updateStormUI() {
            let timerText = '';
            const phaseIndex = Math.min(gameState.currentStormPhase, STORM_PHASES.length - 1);
            const phaseNum = phaseIndex + 1;

            if (gameState.currentStormPhase < 0 || gameState.stormTimer === undefined) {
                 timerText = `Preparing...`; // Or use initial wait time if defined
                 if (STORM_PHASES[0]?.waitDuration) {
                    timerText = `Phase 1 starts in ${Math.ceil(STORM_PHASES[0].waitDuration)}s`;
                 }
            } else if (gameState.stormTimer === Infinity) {
                 timerText = `Phase ${phaseNum} Final Circle`;
            } else if (gameState.isStormShrinking) {
                 timerText = `Phase ${phaseNum} Shrinking: ${Math.ceil(gameState.stormTimer)}s`;
            } else {
                 timerText = `Phase ${phaseNum + 1} starts in ${Math.ceil(gameState.stormTimer)}s`;
            }

            stormTimer.textContent = `Storm: ${timerText}`;

            stormCircle.style.width = `${gameState.stormRadius * 2}px`;
            stormCircle.style.height = `${gameState.stormRadius * 2}px`;
            stormCircle.style.left = `${gameState.stormCenterX - gameState.stormRadius}px`;
            stormCircle.style.top = `${gameState.stormCenterY - gameState.stormRadius}px`;
        }

        function updateMinimap() {
            if (gameState.gameOver) return;
             const minimapWidth = minimapContainer.offsetWidth;
             const minimapHeight = minimapContainer.offsetHeight;

             // Update Player Dot
             if (gameState.player && gameState.player.element) { // Check element exists
                 const minimapX = (gameState.player.x / MAP_WIDTH_PX) * minimapWidth - minimapPlayer.offsetWidth / 2;
                 const minimapY = (gameState.player.y / MAP_HEIGHT_PX) * minimapHeight - minimapPlayer.offsetHeight / 2;
                 minimapPlayer.style.left = `${minimapX}px`;
                 minimapPlayer.style.top = `${minimapY}px`;
             } else if (gameState.player && !gameState.player.element) {
                 // If player exists but element is gone (died), hide minimap dot?
                 minimapPlayer.style.display = 'none';
             } else {
                 minimapPlayer.style.display = 'none'; // Hide if no player
             }


             // Update AI Dots
            gameState.ai.forEach((ai, index) => {
                const dot = gameState.minimapAIDots[index];
                if (ai && dot && ai.element) { // Check AI, dot, and element exist
                     const minimapX = (ai.x / MAP_WIDTH_PX) * minimapWidth - dot.offsetWidth / 2;
                     const minimapY = (ai.y / MAP_HEIGHT_PX) * minimapHeight - dot.offsetHeight / 2;
                     dot.style.left = `${minimapX}px`;
                     dot.style.top = `${minimapY}px`;
                     dot.style.display = 'block'; // Make sure it's visible
                } else if (dot) {
                     dot.style.display = 'none'; // Hide dot if AI or its element is missing
                }
            });

            updateMinimapStorm();
        }

        function updateMinimapStorm() {
            const minimapWidth = minimapContainer.offsetWidth;
            const minimapHeight = minimapContainer.offsetHeight;
            if (minimapWidth <= 0 || minimapHeight <= 0) return; // Skip if minimap not rendered yet

            const minimapRadius = (gameState.stormRadius / MAP_WIDTH_PX) * minimapWidth;
            const minimapCenterX = (gameState.stormCenterX / MAP_WIDTH_PX) * minimapWidth;
            const minimapCenterY = (gameState.stormCenterY / MAP_HEIGHT_PX) * minimapHeight;

            minimapStorm.style.width = `${minimapRadius * 2}px`;
            minimapStorm.style.height = `${minimapRadius * 2}px`;
            minimapStorm.style.left = `${minimapCenterX - minimapRadius}px`;
            minimapStorm.style.top = `${minimapCenterY - minimapRadius}px`;
        }

         function showEndScreen(message) {
             messageText.textContent = message;
             messageScreen.style.display = 'flex';
         }

         function hideEndScreen() {
             messageScreen.style.display = 'none';
         }


        // --- Game Loop ---
        let animationFrameId = null;
        function gameLoop(timestamp) {
            if (!gameState || gameState.gameOver) { // Added !gameState check
                 if (animationFrameId) cancelAnimationFrame(animationFrameId);
                 console.log("Game Over or State Invalid. Loop stopped.");
                 return;
            }

            // Calculate deltaTime robustly
            if (!gameState.lastTimestamp) gameState.lastTimestamp = timestamp; // Initialize if first frame
            gameState.deltaTime = (timestamp - gameState.lastTimestamp) / 1000;
            gameState.lastTimestamp = timestamp;

            // Prevent extreme deltaTime values on lag/resume
            if (gameState.deltaTime > 0.1) gameState.deltaTime = 0.1;
             if (gameState.deltaTime <= 0) { // Skip frame if dt is zero or negative
                 animationFrameId = requestAnimationFrame(gameLoop);
                 return;
             }


            gameState.gameTime += gameState.deltaTime * 1000;

             const dt = gameState.deltaTime;
             const dt_ms = dt * 1000;

            // --- Update Order ---
            // 1. Handle Input / Player Actions (including shooting intent)
            //    (This sets player velocity, angle, shooting state)
            //    (Player pickup/chest interaction)

            // 2. Update AI (sets AI velocity, angle, shooting state, chest opening)
            updateAI(dt); // <<< UPDATE AI FIRST

            // 3. Update Player (apply velocity, collision, hiding, element updates)
             updatePlayer(dt); // <<< THEN UPDATE PLAYER (so AI reacts to previous frame's player pos)

            // 4. Update Projectiles (movement, collision checks against updated entity positions)
            updateProjectiles(dt);

            // 5. Update Health Kit Usage
            updateHealthKitUsage(dt_ms);

            // 6. Update Storm (damage applied based on current entity positions)
            updateStorm(dt);

            // 7. Update UI & Minimap
            updatePlayerCountUI(); // Handles deaths from projectiles/storm this frame
            updateMinimap();

            // 8. Check Win/Loss (mostly handled in entity.die, but double-check needed?)
            //    If player died, gameOver flag is set.
            //    If only player remains, win condition is set in AI die().

            // 9. Request Next Frame
            animationFrameId = requestAnimationFrame(gameLoop);
        } // End gameLoop

        // --- Start the Game ---
        // Wrap in a DOMContentLoaded listener for safety, though script is at end
        document.addEventListener('DOMContentLoaded', () => {
            try {
                initGame();
            } catch (error) {
                console.error("Error during game initialization:", error);
                // Display a user-friendly error message on the page
                 const errorDiv = document.createElement('div');
                 errorDiv.style.color = 'red';
                 errorDiv.style.position = 'absolute';
                 errorDiv.style.top = '50%';
                 errorDiv.style.left = '50%';
                 errorDiv.style.transform = 'translate(-50%, -50%)';
                 errorDiv.style.backgroundColor = 'rgba(0,0,0,0.8)';
                 errorDiv.style.padding = '20px';
                 errorDiv.style.border = '2px solid red';
                 errorDiv.textContent = `Fatal Error Initializing Game. Please check console (F12). Error: ${error.message}`;
                 document.body.appendChild(errorDiv);
                  // Optionally hide other elements
                  if(gameContainer) gameContainer.style.display = 'none';
                  if(uiContainer) uiContainer.style.display = 'none';
                  if(minimapContainer) minimapContainer.style.display = 'none';
            }
        });

    </script>
</body>
</html>