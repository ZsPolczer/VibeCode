<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>90s Retro Maze Game</title>
  <style>
    body {
      background: black;
      color: lime;
      font-family: 'Courier New', monospace;
      text-align: center;
      margin-top: 20px;
    }

    h1 {
      font-size: 32px;
      text-shadow: 0 0 5px cyan, 0 0 10px lime;
    }

    canvas {
      background: black;
      display: block;
      margin: 20px auto;
      border: 4px solid cyan;
    }

    #info {
      font-size: 20px;
      margin-bottom: 10px;
    }

    #message {
      font-size: 24px;
      margin-top: 10px;
      color: yellow;
    }
  </style>
</head>
<body>
  <h1>Retro Maze Game üïπÔ∏è</h1>
  <div id="info">
    Level: <span id="level">1</span> |
    Time Remaining: <span id="timer">60</span>s
  </div>
  <canvas id="mazeCanvas" width="300" height="300"></canvas>
  <div id="message"></div>

  <!-- Confetti Canvas -->
  <canvas id="confettiCanvas" style="position:fixed; top:0; left:0; pointer-events:none;"></canvas>

  <!-- Winning Sound -->
  <audio id="winSound" src="https://www.soundjay.com/buttons/sounds/button-16.mp3"></audio>

  <script>
    const confettiCtx = document.getElementById("confettiCanvas").getContext("2d");
    const confettiCanvas = document.getElementById("confettiCanvas");
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;

    const canvas = document.getElementById("mazeCanvas");
    const ctx = canvas.getContext("2d");

    const tileSize = 30;
    const rows = 10;
    const cols = 10;

    let maze = [];
    let player = { x: 1, y: 1 };
    let goal = { x: 8, y: 8 };

    let baseTime = 60;
    let timeLeft = baseTime;
    let level = 1;
    let timerInterval = null;

    const winSound = document.getElementById("winSound");

    function updateUI() {
      document.getElementById("timer").textContent = timeLeft;
      document.getElementById("level").textContent = level;
    }

    function startTimer() {
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timeLeft--;
        updateUI();
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          document.getElementById("message").textContent = "‚è∞ Time's up!";
          setTimeout(resetGame, 2000);
        }
      }, 1000);
    }

    function resetGame() {
      level = 1;
      baseTime = 60;
      timeLeft = baseTime;
      updateUI();
      generateMaze();
      startTimer();
    }

    function generateMaze() {
      if (timeLeft <= 0) return;

      // Reset full-wall maze
      maze = Array.from({ length: rows }, () => Array(cols).fill(1));

      const stack = [];
      const visited = new Set();

      const directions = [
        [0, -1], // up
        [1, 0],  // right
        [0, 1],  // down
        [-1, 0], // left
      ];

      function getNeighbors(x, y) {
        return directions
          .map(([dx, dy]) => [x + dx * 2, y + dy * 2])
          .filter(
            ([nx, ny]) =>
              nx >= 1 &&
              ny >= 1 &&
              nx < cols - 1 &&
              ny < rows - 1 &&
              !visited.has(`${nx},${ny}`)
          );
      }

      function carve(x1, y1, x2, y2) {
        maze[y1][x1] = 0;
        maze[Math.floor((y1 + y2) / 2)][Math.floor((x1 + x2) / 2)] = 0;
      }

      const startX = 1, startY = 1;
      visited.add(`${startX},${startY}`);
      maze[startY][startX] = 0;
      stack.push([startX, startY]);

      while (stack.length > 0) {
        const current = stack[stack.length - 1];
        const neighbors = getNeighbors(...current);

        if (neighbors.length === 0) {
          stack.pop();
        } else {
          const [nx, ny] = neighbors[Math.floor(Math.random() * neighbors.length)];
          visited.add(`${nx},${ny}`);
          carve(current[0], current[1], nx, ny);
          stack.push([nx, ny]);
        }
      }

      // Find all walkable tiles
      const walkableTiles = [];
      for (let y = 1; y < rows - 1; y++) {
        for (let x = 1; x < cols - 1; x++) {
          if (maze[y][x] === 0) walkableTiles.push({ x, y });
        }
      }

      // BFS to find furthest point from start
      function bfs(startTile) {
        const queue = [{ ...startTile, dist: 0 }];
        const visited = new Set();
        let maxDist = 0;
        let furthestTile = startTile;

        while (queue.length > 0) {
          const { x, y, dist } = queue.shift();
          const key = `${x},${y}`;
          if (visited.has(key)) continue;
          visited.add(key);

          if (dist > maxDist) {
            maxDist = dist;
            furthestTile = { x, y };
          }

          directions.forEach(([dx, dy]) => {
            const nx = x + dx, ny = y + dy;
            if (
              nx >= 0 && ny >= 0 &&
              nx < cols && ny < rows &&
              maze[ny][nx] === 0 &&
              !visited.has(`${nx},${ny}`)
            ) {
              queue.push({ x: nx, y: ny, dist: dist + 1 });
            }
          });
        }

        return furthestTile;
      }

      player = { x: 1, y: 1 };
      goal = bfs(player);

      if (player.x === goal.x && player.y === goal.y) {
        goal = walkableTiles[(walkableTiles.length * 0.75) | 0];
      }

      maze[goal.y][goal.x] = 0;

      drawMaze();
      document.getElementById("message").textContent = "";
    }

    function drawMaze() {
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          ctx.fillStyle = maze[y][x] === 1 ? "#111" : "#000";
          ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
        }
      }

      // Draw walls
      ctx.fillStyle = "#555";
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (maze[y][x] === 1) {
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          }
        }
      }

      // Draw player
      ctx.fillStyle = "cyan";
      ctx.fillRect(player.x * tileSize, player.y * tileSize, tileSize, tileSize);

      // Draw goal
      ctx.fillStyle = "yellow";
      ctx.fillRect(goal.x * tileSize, goal.y * tileSize, tileSize, tileSize);
    }

    function movePlayer(dx, dy) {
      const newX = player.x + dx;
      const newY = player.y + dy;

      if (
        newX >= 0 && newX < cols &&
        newY >= 0 && newY < rows &&
        maze[newY][newX] === 0 &&
        timeLeft > 0
      ) {
        player.x = newX;
        player.y = newY;
        drawMaze();
        checkWin();
      }
    }

    function checkWin() {
      if (player.x === goal.x && player.y === goal.y && timeLeft > 0) {
        winSound.currentTime = 0;
        winSound.play();

        showConfetti();
        document.getElementById("message").textContent = "üéâ Goal Reached!";
        level++;
        if (baseTime > 4) baseTime -= 2;
        timeLeft = baseTime;
        updateUI();

        setTimeout(() => {
          generateMaze();
        }, 1000);
      }
    }

    function showConfetti() {
      const confettiPieces = [];

      for (let i = 0; i < 100; i++) {
        confettiPieces.push({
          x: Math.random() * confettiCanvas.width,
          y: Math.random() * confettiCanvas.height - confettiCanvas.height,
          radius: Math.random() * 5 + 3,
          color: `hsl(${Math.random() * 360}, 100%, 50%)`,
          dx: (Math.random() - 0.5) * 4,
          dy: Math.random() * 4 + 2,
        });
      }

      function animateConfetti() {
        confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        let stillFalling = false;

        for (const p of confettiPieces) {
          p.y += p.dy;
          p.x += p.dx;
          p.dy += 0.05;

          if (p.y < confettiCanvas.height) {
            stillFalling = true;
            confettiCtx.beginPath();
            confettiCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            confettiCtx.fillStyle = p.color;
            confettiCtx.fill();
          }
        }

        if (stillFalling) requestAnimationFrame(animateConfetti);
      }

      animateConfetti();
    }

    window.addEventListener("keydown", (e) => {
      switch (e.key) {
        case "ArrowUp":
          movePlayer(0, -1);
          break;
        case "ArrowDown":
          movePlayer(0, 1);
          break;
        case "ArrowLeft":
          movePlayer(-1, 0);
          break;
        case "ArrowRight":
          movePlayer(1, 0);
          break;
      }
    });

    // Start Game
    updateUI();
    generateMaze();
    startTimer();
  </script>
</body>
</html>